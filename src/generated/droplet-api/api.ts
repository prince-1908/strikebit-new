/* tslint:disable */
/* eslint-disable */
/**
 * Droplet Social
 * The Droplet Social API Docs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivateDto
 */
export interface ActivateDto {
    /**
     * 
     * @type {number}
     * @memberof ActivateDto
     */
    'otp': number;
}
/**
 * 
 * @export
 * @interface AppControllerGetAppSettings401Response
 */
export interface AppControllerGetAppSettings401Response {
    /**
     * 
     * @type {number}
     * @memberof AppControllerGetAppSettings401Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AppControllerGetAppSettings401Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AppControllerGetAppSettings401Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerActivateUser400Response
 */
export interface AuthControllerActivateUser400Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerActivateUser400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerActivateUser400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerActivateUser400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerGoogleSignIn400Response
 */
export interface AuthControllerGoogleSignIn400Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerGoogleSignIn400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGoogleSignIn400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGoogleSignIn400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerLogout401Response
 */
export interface AuthControllerLogout401Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerLogout401Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLogout401Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLogout401Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerRefreshToken200Response
 */
export interface AuthControllerRefreshToken200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthControllerRefreshToken200Response
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerRefreshToken200Response
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerResendVerificationEmail400Response
 */
export interface AuthControllerResendVerificationEmail400Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerResendVerificationEmail400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerResendVerificationEmail400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerResendVerificationEmail400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerResendVerificationEmail404Response
 */
export interface AuthControllerResendVerificationEmail404Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerResendVerificationEmail404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerResendVerificationEmail404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerResendVerificationEmail404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerResetPassword404Response
 */
export interface AuthControllerResetPassword404Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerResetPassword404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerResetPassword404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerResetPassword404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignIn200Response
 */
export interface AuthControllerSignIn200Response {
    /**
     * 
     * @type {object}
     * @memberof AuthControllerSignIn200Response
     */
    'user'?: object;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignIn200Response
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignIn200Response
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignIn401Response
 */
export interface AuthControllerSignIn401Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerSignIn401Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignIn401Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignIn401Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignIn409Response
 */
export interface AuthControllerSignIn409Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerSignIn409Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignIn409Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignIn409Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignup200Response
 */
export interface AuthControllerSignup200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AuthControllerSignup200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignup200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignup409Response
 */
export interface AuthControllerSignup409Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerSignup409Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignup409Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignup409Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignup500Response
 */
export interface AuthControllerSignup500Response {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerSignup500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignup500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerSignup500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface CategoryControllerCreate200Response
 */
export interface CategoryControllerCreate200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CategoryControllerCreate200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CategoryControllerCreate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {CategoryControllerCreate200ResponsePayload}
     * @memberof CategoryControllerCreate200Response
     */
    'payload'?: CategoryControllerCreate200ResponsePayload;
}
/**
 * 
 * @export
 * @interface CategoryControllerCreate200ResponsePayload
 */
export interface CategoryControllerCreate200ResponsePayload {
    /**
     * 
     * @type {string}
     * @memberof CategoryControllerCreate200ResponsePayload
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryControllerCreate200ResponsePayload
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CategoryControllerGetCategories200Response
 */
export interface CategoryControllerGetCategories200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CategoryControllerGetCategories200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CategoryControllerGetCategories200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<CategoryControllerGetCategories200ResponsePayloadInner>}
     * @memberof CategoryControllerGetCategories200Response
     */
    'payload'?: Array<CategoryControllerGetCategories200ResponsePayloadInner>;
}
/**
 * 
 * @export
 * @interface CategoryControllerGetCategories200ResponsePayloadInner
 */
export interface CategoryControllerGetCategories200ResponsePayloadInner {
    /**
     * 
     * @type {string}
     * @memberof CategoryControllerGetCategories200ResponsePayloadInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryControllerGetCategories200ResponsePayloadInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * Current Password
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'currentPassword': string;
    /**
     * New Password
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'newPassword': string;
    /**
     * Confirm Password
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'confirmPassword': string;
}
/**
 * 
 * @export
 * @interface Collaborators
 */
export interface Collaborators {
    /**
     * 
     * @type {string}
     * @memberof Collaborators
     */
    'collaboratorId': string;
    /**
     * 
     * @type {boolean}
     * @memberof Collaborators
     */
    'isAccepted': boolean;
}
/**
 * 
 * @export
 * @interface CollaboratorsDto
 */
export interface CollaboratorsDto {
    /**
     * 
     * @type {string}
     * @memberof CollaboratorsDto
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof CollaboratorsDto
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof CollaboratorsDto
     */
    'email_verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof CollaboratorsDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CollaboratorsDto
     */
    'picture': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollaboratorsDto
     */
    'followers': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollaboratorsDto
     */
    'followee': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CollaboratorsDto
     */
    'sub': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollaboratorsDto
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CollaboratorsDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CollaboratorsDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CommentDataDto
 */
export interface CommentDataDto {
    /**
     * text
     * @type {string}
     * @memberof CommentDataDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface Comments
 */
export interface Comments {
    /**
     * 
     * @type {Sender}
     * @memberof Comments
     */
    'sender': Sender;
    /**
     * 
     * @type {string}
     * @memberof Comments
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ContactUsControllerPostContact200Response
 */
export interface ContactUsControllerPostContact200Response {
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    'inquiryRelatedTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    'issueDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact200Response
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ContactUsControllerPostContact400Response
 */
export interface ContactUsControllerPostContact400Response {
    /**
     * 
     * @type {number}
     * @memberof ContactUsControllerPostContact400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsControllerPostContact400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ContactUsDto
 */
export interface ContactUsDto {
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'inquiryRelatedTo': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'issueDescription': string;
}
/**
 * 
 * @export
 * @interface CreateCategoryDto
 */
export interface CreateCategoryDto {
    /**
     * name
     * @type {string}
     * @memberof CreateCategoryDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateFaqDto
 */
export interface CreateFaqDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFaqDto
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFaqDto
     */
    'answer': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFaqDto
     */
    'category': string;
}
/**
 * 
 * @export
 * @interface DeleteCategoryDto
 */
export interface DeleteCategoryDto {
    /**
     * category id
     * @type {string}
     * @memberof DeleteCategoryDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteChatDto
 */
export interface DeleteChatDto {
    /**
     * chatId
     * @type {string}
     * @memberof DeleteChatDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteStoryDto
 */
export interface DeleteStoryDto {
    /**
     * story id
     * @type {string}
     * @memberof DeleteStoryDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteUserDTO
 */
export interface DeleteUserDTO {
    /**
     * Reason
     * @type {string}
     * @memberof DeleteUserDTO
     */
    'deletionReason'?: string;
    /**
     * comments
     * @type {string}
     * @memberof DeleteUserDTO
     */
    'deletionComments'?: string;
}
/**
 * 
 * @export
 * @interface DeviceDto
 */
export interface DeviceDto {
    /**
     * Device ID
     * @type {string}
     * @memberof DeviceDto
     */
    'deviceId'?: string;
    /**
     * Device Name
     * @type {string}
     * @memberof DeviceDto
     */
    'deviceName'?: string;
    /**
     * Device OS
     * @type {string}
     * @memberof DeviceDto
     */
    'deviceOS'?: string;
    /**
     * Device OS Version
     * @type {string}
     * @memberof DeviceDto
     */
    'osVersion'?: string;
    /**
     * FCM Token
     * @type {string}
     * @memberof DeviceDto
     */
    'fcmToken'?: string;
}
/**
 * 
 * @export
 * @interface FaqsControllerGetFaqs200Response
 */
export interface FaqsControllerGetFaqs200Response {
    /**
     * 
     * @type {Array<FaqsControllerGetFaqs200ResponseFaqsInner>}
     * @memberof FaqsControllerGetFaqs200Response
     */
    'faqs'?: Array<FaqsControllerGetFaqs200ResponseFaqsInner>;
    /**
     * 
     * @type {number}
     * @memberof FaqsControllerGetFaqs200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface FaqsControllerGetFaqs200ResponseFaqsInner
 */
export interface FaqsControllerGetFaqs200ResponseFaqsInner {
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs200ResponseFaqsInner
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs200ResponseFaqsInner
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs200ResponseFaqsInner
     */
    'answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs200ResponseFaqsInner
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs200ResponseFaqsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs200ResponseFaqsInner
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FaqsControllerGetFaqs500Response
 */
export interface FaqsControllerGetFaqs500Response {
    /**
     * 
     * @type {number}
     * @memberof FaqsControllerGetFaqs500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerGetFaqs500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface FaqsControllerUpdateFaq404Response
 */
export interface FaqsControllerUpdateFaq404Response {
    /**
     * 
     * @type {number}
     * @memberof FaqsControllerUpdateFaq404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerUpdateFaq404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FaqsControllerUpdateFaq404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface FollowProfileDto
 */
export interface FollowProfileDto {
    /**
     * 
     * @type {string}
     * @memberof FollowProfileDto
     */
    'profileId': string;
}
/**
 * 
 * @export
 * @interface GoogleLoginDto
 */
export interface GoogleLoginDto {
    /**
     * ID Token
     * @type {string}
     * @memberof GoogleLoginDto
     */
    'idToken'?: string;
    /**
     * Device Object
     * @type {DeviceDto}
     * @memberof GoogleLoginDto
     */
    'deviceDetails'?: DeviceDto;
    /**
     * lang
     * @type {string}
     * @memberof GoogleLoginDto
     */
    'lang'?: GoogleLoginDtoLangEnum;
}

export const GoogleLoginDtoLangEnum = {
    En: 'en',
    Ko: 'ko'
} as const;

export type GoogleLoginDtoLangEnum = typeof GoogleLoginDtoLangEnum[keyof typeof GoogleLoginDtoLangEnum];

/**
 * 
 * @export
 * @interface InstagramLoginDto
 */
export interface InstagramLoginDto {
    /**
     * Instagram user_id
     * @type {string}
     * @memberof InstagramLoginDto
     */
    'user_id'?: string;
    /**
     * Instagram access_token
     * @type {string}
     * @memberof InstagramLoginDto
     */
    'access_token'?: string;
    /**
     * Device Object
     * @type {DeviceDto}
     * @memberof InstagramLoginDto
     */
    'deviceDetails'?: DeviceDto;
    /**
     * lang
     * @type {string}
     * @memberof InstagramLoginDto
     */
    'lang'?: InstagramLoginDtoLangEnum;
}

export const InstagramLoginDtoLangEnum = {
    En: 'en',
    Ko: 'ko'
} as const;

export type InstagramLoginDtoLangEnum = typeof InstagramLoginDtoLangEnum[keyof typeof InstagramLoginDtoLangEnum];

/**
 * 
 * @export
 * @interface LocationDto
 */
export interface LocationDto {
    /**
     * 
     * @type {string}
     * @memberof LocationDto
     */
    'addressText'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationDto
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationDto
     */
    'longitude'?: string;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * email
     * @type {string}
     * @memberof LoginDto
     */
    'email'?: string;
    /**
     * password
     * @type {string}
     * @memberof LoginDto
     */
    'password'?: string;
    /**
     * Device Object
     * @type {DeviceDto}
     * @memberof LoginDto
     */
    'deviceDetails'?: DeviceDto;
    /**
     * lang
     * @type {string}
     * @memberof LoginDto
     */
    'lang'?: LoginDtoLangEnum;
}

export const LoginDtoLangEnum = {
    En: 'en',
    Ko: 'ko'
} as const;

export type LoginDtoLangEnum = typeof LoginDtoLangEnum[keyof typeof LoginDtoLangEnum];

/**
 * 
 * @export
 * @interface LogoutDto
 */
export interface LogoutDto {
    /**
     * Device ID
     * @type {string}
     * @memberof LogoutDto
     */
    'deviceId'?: string;
}
/**
 * 
 * @export
 * @interface NewUserDTO
 */
export interface NewUserDTO {
    /**
     * email
     * @type {string}
     * @memberof NewUserDTO
     */
    'email'?: string;
    /**
     * password
     * @type {string}
     * @memberof NewUserDTO
     */
    'password'?: string;
    /**
     * referral code
     * @type {string}
     * @memberof NewUserDTO
     */
    'referralCode'?: string;
    /**
     * lang
     * @type {string}
     * @memberof NewUserDTO
     */
    'lang'?: NewUserDTOLangEnum;
}

export const NewUserDTOLangEnum = {
    En: 'en',
    Ko: 'ko'
} as const;

export type NewUserDTOLangEnum = typeof NewUserDTOLangEnum[keyof typeof NewUserDTOLangEnum];

/**
 * 
 * @export
 * @interface PaymentIntentForPostDTO
 */
export interface PaymentIntentForPostDTO {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntentForPostDTO
     */
    'postId': string;
}
/**
 * 
 * @export
 * @interface PostControllerAddComment500Response
 */
export interface PostControllerAddComment500Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerAddComment500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerAddComment500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerAddComment500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerCreateDraft400Response
 */
export interface PostControllerCreateDraft400Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerCreateDraft400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreateDraft400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreateDraft400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerCreatePost400Response
 */
export interface PostControllerCreatePost400Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerCreatePost400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreatePost400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreatePost400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerCreatePost403Response
 */
export interface PostControllerCreatePost403Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerCreatePost403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreatePost403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreatePost403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerCreatePost500Response
 */
export interface PostControllerCreatePost500Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerCreatePost500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreatePost500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerCreatePost500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerDeleteDraft404Response
 */
export interface PostControllerDeleteDraft404Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerDeleteDraft404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerDeleteDraft404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerDeleteDraft404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerDeletePost404Response
 */
export interface PostControllerDeletePost404Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerDeletePost404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerDeletePost404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerDeletePost404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerGetAllDrafts200Response
 */
export interface PostControllerGetAllDrafts200Response {
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PostControllerGetAllDrafts200ResponsePayload}
     * @memberof PostControllerGetAllDrafts200Response
     */
    'payload'?: PostControllerGetAllDrafts200ResponsePayload;
}
/**
 * 
 * @export
 * @interface PostControllerGetAllDrafts200ResponsePayload
 */
export interface PostControllerGetAllDrafts200ResponsePayload {
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    '_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'category'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'media'?: Array<string>;
    /**
     * 
     * @type {PostControllerGetAllDrafts200ResponsePayloadUserId}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'userId'?: PostControllerGetAllDrafts200ResponsePayloadUserId;
    /**
     * 
     * @type {PostControllerGetAllDrafts200ResponsePayloadStats}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'stats'?: PostControllerGetAllDrafts200ResponsePayloadStats;
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'isLiked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'isPrivate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'isBlur'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'isAdultContent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'createdAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'isLocation'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'isScheduled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'isDraft'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'location'?: object;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayload
     */
    'scheduledFor'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerGetAllDrafts200ResponsePayloadStats
 */
export interface PostControllerGetAllDrafts200ResponsePayloadStats {
    /**
     * 
     * @type {number}
     * @memberof PostControllerGetAllDrafts200ResponsePayloadStats
     */
    'likesCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PostControllerGetAllDrafts200ResponsePayloadStats
     */
    'commentsCount'?: number;
}
/**
 * 
 * @export
 * @interface PostControllerGetAllDrafts200ResponsePayloadUserId
 */
export interface PostControllerGetAllDrafts200ResponsePayloadUserId {
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayloadUserId
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayloadUserId
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts200ResponsePayloadUserId
     */
    'picture'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerGetAllDrafts404Response
 */
export interface PostControllerGetAllDrafts404Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerGetAllDrafts404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllDrafts404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerGetAllRecommendedPostsForFeed404Response
 */
export interface PostControllerGetAllRecommendedPostsForFeed404Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerGetAllRecommendedPostsForFeed404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllRecommendedPostsForFeed404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetAllRecommendedPostsForFeed404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerGetUsersCollaboratorsPosts500Response
 */
export interface PostControllerGetUsersCollaboratorsPosts500Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerGetUsersCollaboratorsPosts500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetUsersCollaboratorsPosts500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerGetUsersCollaboratorsPosts500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerLikePost403Response
 */
export interface PostControllerLikePost403Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerLikePost403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerLikePost403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerLikePost403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerLikePost500Response
 */
export interface PostControllerLikePost500Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerLikePost500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerLikePost500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerLikePost500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerUnlikePost403Response
 */
export interface PostControllerUnlikePost403Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerUnlikePost403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUnlikePost403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUnlikePost403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerUpdateComment200Response
 */
export interface PostControllerUpdateComment200Response {
    /**
     * 
     * @type {boolean}
     * @memberof PostControllerUpdateComment200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PostControllerUpdateComment200ResponsePayload}
     * @memberof PostControllerUpdateComment200Response
     */
    'payload'?: PostControllerUpdateComment200ResponsePayload;
}
/**
 * 
 * @export
 * @interface PostControllerUpdateComment200ResponsePayload
 */
export interface PostControllerUpdateComment200ResponsePayload {
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment200ResponsePayload
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment200ResponsePayload
     */
    'text'?: string;
    /**
     * 
     * @type {PostControllerGetAllDrafts200ResponsePayloadUserId}
     * @memberof PostControllerUpdateComment200ResponsePayload
     */
    'sender'?: PostControllerGetAllDrafts200ResponsePayloadUserId;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment200ResponsePayload
     */
    'post'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment200ResponsePayload
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment200ResponsePayload
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerUpdateComment404Response
 */
export interface PostControllerUpdateComment404Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerUpdateComment404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdateComment404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerUpdatePost400Response
 */
export interface PostControllerUpdatePost400Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerUpdatePost400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdatePost400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdatePost400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostControllerUpdatePost500Response
 */
export interface PostControllerUpdatePost500Response {
    /**
     * 
     * @type {number}
     * @memberof PostControllerUpdatePost500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdatePost500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PostControllerUpdatePost500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostResponseDto
 */
export interface PostResponseDto {
    /**
     * 
     * @type {string}
     * @memberof PostResponseDto
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof PostResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostResponseDto
     */
    'likes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostResponseDto
     */
    'time': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostResponseDto
     */
    'media': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostResponseDto
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostResponseDto
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostResponseDto
     */
    'category': string;
    /**
     * 
     * @type {Array<Collaborators>}
     * @memberof PostResponseDto
     */
    'collaborators': Array<Collaborators>;
    /**
     * 
     * @type {boolean}
     * @memberof PostResponseDto
     */
    'isPrivate': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostResponseDto
     */
    'isBlur': boolean;
    /**
     * 
     * @type {number}
     * @memberof PostResponseDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PostResponseDto
     */
    'date': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostResponseDto
     */
    'isLocation': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostResponseDto
     */
    'isAdultContent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostResponseDto
     */
    'isDraft': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostResponseDto
     */
    'isDeleted': boolean;
    /**
     * 
     * @type {Array<Comments>}
     * @memberof PostResponseDto
     */
    'comments': Array<Comments>;
    /**
     * 
     * @type {Reactions}
     * @memberof PostResponseDto
     */
    'reactions': Reactions;
    /**
     * 
     * @type {string}
     * @memberof PostResponseDto
     */
    'postTime': string;
}
/**
 * 
 * @export
 * @interface ProfileSetupOneDto
 */
export interface ProfileSetupOneDto {
    /**
     * display name
     * @type {string}
     * @memberof ProfileSetupOneDto
     */
    'name'?: string;
    /**
     * username
     * @type {string}
     * @memberof ProfileSetupOneDto
     */
    'username'?: string;
    /**
     * description
     * @type {string}
     * @memberof ProfileSetupOneDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ReactionDetails
 */
export interface ReactionDetails {
    /**
     * 
     * @type {number}
     * @memberof ReactionDetails
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReactionDetails
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface Reactions
 */
export interface Reactions {
    /**
     * 
     * @type {ReactionDetails}
     * @memberof Reactions
     */
    'utfsAsKey': ReactionDetails;
}
/**
 * 
 * @export
 * @interface RecentSearchTextDto
 */
export interface RecentSearchTextDto {
    /**
     * 
     * @type {string}
     * @memberof RecentSearchTextDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface RemoveSubscriberTierDto
 */
export interface RemoveSubscriberTierDto {
    /**
     * tier Id
     * @type {string}
     * @memberof RemoveSubscriberTierDto
     */
    'tierId': string;
    /**
     * subscriberId
     * @type {string}
     * @memberof RemoveSubscriberTierDto
     */
    'subscriberId': string;
}
/**
 * 
 * @export
 * @interface ReportProblemControllerReportProblem200Response
 */
export interface ReportProblemControllerReportProblem200Response {
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem200Response
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem200Response
     */
    'inquiryRelatedTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem200Response
     */
    'issueDescription'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReportProblemControllerReportProblem200Response
     */
    'screenShots'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem200Response
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem200Response
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ReportProblemControllerReportProblem400Response
 */
export interface ReportProblemControllerReportProblem400Response {
    /**
     * 
     * @type {number}
     * @memberof ReportProblemControllerReportProblem400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ReportProblemControllerReportProblem500Response
 */
export interface ReportProblemControllerReportProblem500Response {
    /**
     * 
     * @type {number}
     * @memberof ReportProblemControllerReportProblem500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ReportProblemControllerReportProblem502Response
 */
export interface ReportProblemControllerReportProblem502Response {
    /**
     * 
     * @type {number}
     * @memberof ReportProblemControllerReportProblem502Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem502Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ReportProblemControllerReportProblem502Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ResetPasswordDto
 */
export interface ResetPasswordDto {
    /**
     * OTP
     * @type {string}
     * @memberof ResetPasswordDto
     */
    'otp'?: string;
    /**
     * password
     * @type {string}
     * @memberof ResetPasswordDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ResponseConversationDto
 */
export interface ResponseConversationDto {
    /**
     * chat data
     * @type {Array<object>}
     * @memberof ResponseConversationDto
     */
    'conversations': Array<object>;
    /**
     * total documents
     * @type {number}
     * @memberof ResponseConversationDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ResponseStoryDto
 */
export interface ResponseStoryDto {
    /**
     * images/videos
     * @type {Array<File>}
     * @memberof ResponseStoryDto
     */
    'media': Array<File>;
    /**
     * description
     * @type {string}
     * @memberof ResponseStoryDto
     */
    'description': string;
    /**
     * Creator id
     * @type {string}
     * @memberof ResponseStoryDto
     */
    'creatorId': string;
    /**
     * Creator id
     * @type {string}
     * @memberof ResponseStoryDto
     */
    'createdAt': string;
    /**
     * Creator id
     * @type {string}
     * @memberof ResponseStoryDto
     */
    'updatedAt': string;
    /**
     * id
     * @type {string}
     * @memberof ResponseStoryDto
     */
    '_id': string;
}
/**
 * 
 * @export
 * @interface ResponseStoryPaginationDto
 */
export interface ResponseStoryPaginationDto {
    /**
     * stories data
     * @type {Array<ResponseStoryDto>}
     * @memberof ResponseStoryPaginationDto
     */
    'stories': Array<ResponseStoryDto>;
    /**
     * total documents
     * @type {number}
     * @memberof ResponseStoryPaginationDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface Sender
 */
export interface Sender {
    /**
     * 
     * @type {string}
     * @memberof Sender
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Sender
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Sender
     */
    'picture': string;
}
/**
 * 
 * @export
 * @interface StripeControllerCreateCheckoutSession200Response
 */
export interface StripeControllerCreateCheckoutSession200Response {
    /**
     * 
     * @type {boolean}
     * @memberof StripeControllerCreateCheckoutSession200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {StripeControllerCreateCheckoutSession200ResponsePayload}
     * @memberof StripeControllerCreateCheckoutSession200Response
     */
    'payload'?: StripeControllerCreateCheckoutSession200ResponsePayload;
}
/**
 * 
 * @export
 * @interface StripeControllerCreateCheckoutSession200ResponsePayload
 */
export interface StripeControllerCreateCheckoutSession200ResponsePayload {
    /**
     * 
     * @type {string}
     * @memberof StripeControllerCreateCheckoutSession200ResponsePayload
     */
    'client_secret'?: string;
}
/**
 * 
 * @export
 * @interface StripeControllerCreateCheckoutSession400Response
 */
export interface StripeControllerCreateCheckoutSession400Response {
    /**
     * 
     * @type {number}
     * @memberof StripeControllerCreateCheckoutSession400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof StripeControllerCreateCheckoutSession400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof StripeControllerCreateCheckoutSession400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface StripeControllerCreateSubscription200Response
 */
export interface StripeControllerCreateSubscription200Response {
    /**
     * 
     * @type {boolean}
     * @memberof StripeControllerCreateSubscription200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {StripeControllerCreateSubscription200ResponsePayload}
     * @memberof StripeControllerCreateSubscription200Response
     */
    'payload'?: StripeControllerCreateSubscription200ResponsePayload;
}
/**
 * 
 * @export
 * @interface StripeControllerCreateSubscription200ResponsePayload
 */
export interface StripeControllerCreateSubscription200ResponsePayload {
    /**
     * 
     * @type {string}
     * @memberof StripeControllerCreateSubscription200ResponsePayload
     */
    'client_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeControllerCreateSubscription200ResponsePayload
     */
    'customer'?: string;
}
/**
 * 
 * @export
 * @interface StripeControllerCreateSubscription400Response
 */
export interface StripeControllerCreateSubscription400Response {
    /**
     * 
     * @type {number}
     * @memberof StripeControllerCreateSubscription400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof StripeControllerCreateSubscription400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof StripeControllerCreateSubscription400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface SubscribeTierDto
 */
export interface SubscribeTierDto {
    /**
     * 
     * @type {string}
     * @memberof SubscribeTierDto
     */
    'tierId': string;
}
/**
 * 
 * @export
 * @interface Subscriber
 */
export interface Subscriber {
    /**
     * 
     * @type {string}
     * @memberof Subscriber
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Subscriber
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Subscriber
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Subscriber
     */
    'picture': string;
}
/**
 * 
 * @export
 * @interface Subscribers
 */
export interface Subscribers {
    /**
     * 
     * @type {Subscriber}
     * @memberof Subscribers
     */
    'subscriber': Subscriber;
    /**
     * 
     * @type {string}
     * @memberof Subscribers
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface SubscriptionDTO
 */
export interface SubscriptionDTO {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDTO
     */
    'tierId': string;
}
/**
 * 
 * @export
 * @interface TiersControllerCreateTier400Response
 */
export interface TiersControllerCreateTier400Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerCreateTier400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerCreateTier400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerCreateTier400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerCreateTier403Response
 */
export interface TiersControllerCreateTier403Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerCreateTier403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerCreateTier403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerCreateTier403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerGetTierById404Response
 */
export interface TiersControllerGetTierById404Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerGetTierById404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerGetTierById404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerGetTierById404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerGetTiers404Response
 */
export interface TiersControllerGetTiers404Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerGetTiers404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerGetTiers404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerGetTiers404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerGetTiersSubscribers404Response
 */
export interface TiersControllerGetTiersSubscribers404Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerGetTiersSubscribers404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerGetTiersSubscribers404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerGetTiersSubscribers404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerRemoveSubscriber400Response
 */
export interface TiersControllerRemoveSubscriber400Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerRemoveSubscriber400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerRemoveSubscriber400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerRemoveSubscriber400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerRemoveSubscriber500Response
 */
export interface TiersControllerRemoveSubscriber500Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerRemoveSubscriber500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerRemoveSubscriber500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerRemoveSubscriber500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerUnSubscribeTier500Response
 */
export interface TiersControllerUnSubscribeTier500Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerUnSubscribeTier500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUnSubscribeTier500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUnSubscribeTier500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerUpdateTier200Response
 */
export interface TiersControllerUpdateTier200Response {
    /**
     * 
     * @type {boolean}
     * @memberof TiersControllerUpdateTier200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200Response
     */
    'message'?: string;
    /**
     * 
     * @type {TiersControllerUpdateTier200ResponsePayload}
     * @memberof TiersControllerUpdateTier200Response
     */
    'payload'?: TiersControllerUpdateTier200ResponsePayload;
}
/**
 * 
 * @export
 * @interface TiersControllerUpdateTier200ResponsePayload
 */
export interface TiersControllerUpdateTier200ResponsePayload {
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'benefits'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'avatar'?: string;
    /**
     * 
     * @type {number}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'level'?: number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserControllerGetMyTiers200ResponsePayloadInnerStats}
     * @memberof TiersControllerUpdateTier200ResponsePayload
     */
    'stats'?: UserControllerGetMyTiers200ResponsePayloadInnerStats;
}
/**
 * 
 * @export
 * @interface TiersControllerUpdateTier400Response
 */
export interface TiersControllerUpdateTier400Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerUpdateTier400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerUpdateTier403Response
 */
export interface TiersControllerUpdateTier403Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerUpdateTier403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersControllerUpdateTier500Response
 */
export interface TiersControllerUpdateTier500Response {
    /**
     * 
     * @type {number}
     * @memberof TiersControllerUpdateTier500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TiersControllerUpdateTier500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TiersResponseDto
 */
export interface TiersResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TiersResponseDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof TiersResponseDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof TiersResponseDto
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof TiersResponseDto
     */
    'benefits'?: string;
    /**
     * 
     * @type {string}
     * @memberof TiersResponseDto
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof TiersResponseDto
     */
    'creatorId': string;
    /**
     * 
     * @type {number}
     * @memberof TiersResponseDto
     */
    'level': number;
    /**
     * 
     * @type {string}
     * @memberof TiersResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TiersResponseDto
     */
    'updateAt': string;
    /**
     * 
     * @type {Array<Subscribers>}
     * @memberof TiersResponseDto
     */
    'subscribers': Array<Subscribers>;
}
/**
 * 
 * @export
 * @interface UnFollowProfileDto
 */
export interface UnFollowProfileDto {
    /**
     * 
     * @type {string}
     * @memberof UnFollowProfileDto
     */
    'profileId': string;
}
/**
 * 
 * @export
 * @interface UpdateCommentDto
 */
export interface UpdateCommentDto {
    /**
     * text
     * @type {string}
     * @memberof UpdateCommentDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface UpdateFaqDto
 */
export interface UpdateFaqDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateFaqDto
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFaqDto
     */
    'answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFaqDto
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface UpdateFollowStatusDto
 */
export interface UpdateFollowStatusDto {
    /**
     * status
     * @type {string}
     * @memberof UpdateFollowStatusDto
     */
    'status': string;
    /**
     * profileId
     * @type {string}
     * @memberof UpdateFollowStatusDto
     */
    'profileId': string;
}
/**
 * 
 * @export
 * @interface UpdateStatusDto
 */
export interface UpdateStatusDto {
    /**
     * Status Text
     * @type {string}
     * @memberof UpdateStatusDto
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSubscriptionStatusAsOwnerDto
 */
export interface UpdateSubscriptionStatusAsOwnerDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSubscriptionStatusAsOwnerDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSubscriptionStatusAsOwnerDto
     */
    'subscriberId': string;
}
/**
 * 
 * @export
 * @interface UserControllerAddFollower400Response
 */
export interface UserControllerAddFollower400Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerAddFollower400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerAddFollower400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerAddFollower400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerAddFollower403Response
 */
export interface UserControllerAddFollower403Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerAddFollower403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerAddFollower403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerAddFollower403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerDeleteUser403Response
 */
export interface UserControllerDeleteUser403Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerDeleteUser403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerDeleteUser403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerDeleteUser403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerFindOne200Response
 */
export interface UserControllerFindOne200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerFindOne200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200Response
     */
    'message'?: string;
    /**
     * 
     * @type {UserControllerFindOne200ResponsePayload}
     * @memberof UserControllerFindOne200Response
     */
    'payload'?: UserControllerFindOne200ResponsePayload;
}
/**
 * 
 * @export
 * @interface UserControllerFindOne200ResponsePayload
 */
export interface UserControllerFindOne200ResponsePayload {
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'profileSetupStage'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'picture'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'sub'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'followers'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'followersCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'followee'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'followingsCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'description'?: string;
    /**
     * 
     * @type {UserControllerFindOne200ResponsePayloadSocials}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'socials'?: UserControllerFindOne200ResponsePayloadSocials;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayload
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerFindOne200ResponsePayloadSocials
 */
export interface UserControllerFindOne200ResponsePayloadSocials {
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayloadSocials
     */
    'instagram'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayloadSocials
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayloadSocials
     */
    'behance'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne200ResponsePayloadSocials
     */
    'website'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerFindOne200ResponsePayloadSocials
     */
    'links'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserControllerFindOne500Response
 */
export interface UserControllerFindOne500Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerFindOne500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFindOne500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerFollowRequests200Response
 */
export interface UserControllerFollowRequests200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerFollowRequests200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<UserControllerFollowRequests200ResponsePayloadInner>}
     * @memberof UserControllerFollowRequests200Response
     */
    'payload'?: Array<UserControllerFollowRequests200ResponsePayloadInner>;
}
/**
 * 
 * @export
 * @interface UserControllerFollowRequests200ResponsePayloadInner
 */
export interface UserControllerFollowRequests200ResponsePayloadInner {
    /**
     * 
     * @type {string}
     * @memberof UserControllerFollowRequests200ResponsePayloadInner
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFollowRequests200ResponsePayloadInner
     */
    'picture'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerFollowRequests200ResponsePayloadInner
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerGetCollaborators500Response
 */
export interface UserControllerGetCollaborators500Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetCollaborators500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetCollaborators500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetCollaborators500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerGetMyFollowers500Response
 */
export interface UserControllerGetMyFollowers500Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetMyFollowers500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyFollowers500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyFollowers500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerGetMyPosts404Response
 */
export interface UserControllerGetMyPosts404Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetMyPosts404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyPosts404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyPosts404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerGetMyTiers200Response
 */
export interface UserControllerGetMyTiers200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetMyTiers200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<UserControllerGetMyTiers200ResponsePayloadInner>}
     * @memberof UserControllerGetMyTiers200Response
     */
    'payload'?: Array<UserControllerGetMyTiers200ResponsePayloadInner>;
}
/**
 * 
 * @export
 * @interface UserControllerGetMyTiers200ResponsePayloadInner
 */
export interface UserControllerGetMyTiers200ResponsePayloadInner {
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'benefits'?: Array<string>;
    /**
     * 
     * @type {UserControllerGetMyTiers200ResponsePayloadInnerStats}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'stats'?: UserControllerGetMyTiers200ResponsePayloadInnerStats;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'avatar'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'level'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInner
     */
    'subscribers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserControllerGetMyTiers200ResponsePayloadInnerStats
 */
export interface UserControllerGetMyTiers200ResponsePayloadInnerStats {
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetMyTiers200ResponsePayloadInnerStats
     */
    'subscribersCount'?: number;
}
/**
 * 
 * @export
 * @interface UserControllerGetNotificationSettings200Response
 */
export interface UserControllerGetNotificationSettings200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetNotificationSettings200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetNotificationSettings200Response
     */
    'message'?: string;
    /**
     * 
     * @type {UserControllerGetNotificationSettings200ResponsePayload}
     * @memberof UserControllerGetNotificationSettings200Response
     */
    'payload'?: UserControllerGetNotificationSettings200ResponsePayload;
}
/**
 * 
 * @export
 * @interface UserControllerGetNotificationSettings200ResponsePayload
 */
export interface UserControllerGetNotificationSettings200ResponsePayload {
    /**
     * 
     * @type {UserControllerUpdateSettings200ResponsePayloadNotifications}
     * @memberof UserControllerGetNotificationSettings200ResponsePayload
     */
    'notifications'?: UserControllerUpdateSettings200ResponsePayloadNotifications;
}
/**
 * 
 * @export
 * @interface UserControllerGetPrivacySettings200Response
 */
export interface UserControllerGetPrivacySettings200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetPrivacySettings200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetPrivacySettings200Response
     */
    'message'?: string;
    /**
     * 
     * @type {UserControllerGetPrivacySettings200ResponsePayload}
     * @memberof UserControllerGetPrivacySettings200Response
     */
    'payload'?: UserControllerGetPrivacySettings200ResponsePayload;
}
/**
 * 
 * @export
 * @interface UserControllerGetPrivacySettings200ResponsePayload
 */
export interface UserControllerGetPrivacySettings200ResponsePayload {
    /**
     * 
     * @type {UserControllerGetPrivacySettings200ResponsePayloadPrivacy}
     * @memberof UserControllerGetPrivacySettings200ResponsePayload
     */
    'privacy'?: UserControllerGetPrivacySettings200ResponsePayloadPrivacy;
    /**
     * 
     * @type {UserControllerUpdateSettings200ResponsePayloadSecurity}
     * @memberof UserControllerGetPrivacySettings200ResponsePayload
     */
    'security'?: UserControllerUpdateSettings200ResponsePayloadSecurity;
}
/**
 * 
 * @export
 * @interface UserControllerGetPrivacySettings200ResponsePayloadPrivacy
 */
export interface UserControllerGetPrivacySettings200ResponsePayloadPrivacy {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetPrivacySettings200ResponsePayloadPrivacy
     */
    'showPost'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetPrivacySettings200ResponsePayloadPrivacy
     */
    'showStory'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetPrivacySettings200ResponsePayloadPrivacy
     */
    'allowMentionBy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetPrivacySettings200ResponsePayloadPrivacy
     */
    'showLikesNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetPrivacySettings200ResponsePayloadPrivacy
     */
    'showCommentsNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetPrivacySettings200ResponsePayloadPrivacy
     */
    'isProfilePrivate'?: boolean;
}
/**
 * 
 * @export
 * @interface UserControllerGetRecommendedProfiles403Response
 */
export interface UserControllerGetRecommendedProfiles403Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetRecommendedProfiles403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetRecommendedProfiles403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetRecommendedProfiles403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerGetTrendingUsers200Response
 */
export interface UserControllerGetTrendingUsers200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerGetTrendingUsers200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetTrendingUsers200Response
     */
    'message'?: string;
    /**
     * 
     * @type {UserControllerGetTrendingUsers200ResponsePayload}
     * @memberof UserControllerGetTrendingUsers200Response
     */
    'payload'?: UserControllerGetTrendingUsers200ResponsePayload;
}
/**
 * 
 * @export
 * @interface UserControllerGetTrendingUsers200ResponsePayload
 */
export interface UserControllerGetTrendingUsers200ResponsePayload {
    /**
     * 
     * @type {Array<object>}
     * @memberof UserControllerGetTrendingUsers200ResponsePayload
     */
    'data'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetTrendingUsers200ResponsePayload
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface UserControllerGetUser400Response
 */
export interface UserControllerGetUser400Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetUser400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetUser400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetUser400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerGetUser404Response
 */
export interface UserControllerGetUser404Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerGetUser404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetUser404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerGetUser404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerProfileSetup404Response
 */
export interface UserControllerProfileSetup404Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerProfileSetup404Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerProfileSetup404Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerProfileSetup404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerProfileSetupAboutRequest
 */
export interface UserControllerProfileSetupAboutRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerProfileSetupAboutRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {UserControllerUpdateUserByUserIdRequestSocials}
     * @memberof UserControllerProfileSetupAboutRequest
     */
    'socials'?: UserControllerUpdateUserByUserIdRequestSocials;
    /**
     * 
     * @type {string}
     * @memberof UserControllerProfileSetupAboutRequest
     */
    'category'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerProfileSetupAboutRequest
     */
    'skip'?: boolean;
}
/**
 * 
 * @export
 * @interface UserControllerProfileSetupAvatar403Response
 */
export interface UserControllerProfileSetupAvatar403Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerProfileSetupAvatar403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerProfileSetupAvatar403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerProfileSetupAvatar403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerUnFollow403Response
 */
export interface UserControllerUnFollow403Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerUnFollow403Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUnFollow403Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUnFollow403Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerUnFollower400Response
 */
export interface UserControllerUnFollower400Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerUnFollower400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUnFollower400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUnFollower400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerUpdateSettings200Response
 */
export interface UserControllerUpdateSettings200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUpdateSettings200Response
     */
    'message'?: string;
    /**
     * 
     * @type {UserControllerUpdateSettings200ResponsePayload}
     * @memberof UserControllerUpdateSettings200Response
     */
    'payload'?: UserControllerUpdateSettings200ResponsePayload;
}
/**
 * 
 * @export
 * @interface UserControllerUpdateSettings200ResponsePayload
 */
export interface UserControllerUpdateSettings200ResponsePayload {
    /**
     * 
     * @type {UserControllerUpdateSettings200ResponsePayloadPrivacy}
     * @memberof UserControllerUpdateSettings200ResponsePayload
     */
    'privacy'?: UserControllerUpdateSettings200ResponsePayloadPrivacy;
    /**
     * 
     * @type {UserControllerUpdateSettings200ResponsePayloadSecurity}
     * @memberof UserControllerUpdateSettings200ResponsePayload
     */
    'security'?: UserControllerUpdateSettings200ResponsePayloadSecurity;
    /**
     * 
     * @type {UserControllerUpdateSettings200ResponsePayloadNotifications}
     * @memberof UserControllerUpdateSettings200ResponsePayload
     */
    'notifications'?: UserControllerUpdateSettings200ResponsePayloadNotifications;
}
/**
 * 
 * @export
 * @interface UserControllerUpdateSettings200ResponsePayloadNotifications
 */
export interface UserControllerUpdateSettings200ResponsePayloadNotifications {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'allowPush'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'postComments'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'postLikes'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'replyOnStory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'likeAndCommentOnPhoto'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'newFollowers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'acceptedFollowRequests'?: boolean;
    /**
     * 
     * @type {UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotifications
     */
    'nftNotificationsOn'?: UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn;
}
/**
 * 
 * @export
 * @interface UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn
 */
export interface UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn
     */
    'sales'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn
     */
    'successfulBid'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn
     */
    'bidsAndOutBids'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn
     */
    'expiredBids'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadNotificationsNftNotificationsOn
     */
    'suggestedDrops'?: boolean;
}
/**
 * 
 * @export
 * @interface UserControllerUpdateSettings200ResponsePayloadPrivacy
 */
export interface UserControllerUpdateSettings200ResponsePayloadPrivacy {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadPrivacy
     */
    'showPost'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadPrivacy
     */
    'showStory'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUpdateSettings200ResponsePayloadPrivacy
     */
    'allowMentionBy'?: string;
}
/**
 * 
 * @export
 * @interface UserControllerUpdateSettings200ResponsePayloadSecurity
 */
export interface UserControllerUpdateSettings200ResponsePayloadSecurity {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadSecurity
     */
    'twoFactorAuth'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUpdateSettings200ResponsePayloadSecurity
     */
    'googleAuthenticator'?: boolean;
}
/**
 * 
 * @export
 * @interface UserControllerUpdateUserByUserIdRequestSocials
 */
export interface UserControllerUpdateUserByUserIdRequestSocials {
    /**
     * 
     * @type {string}
     * @memberof UserControllerUpdateUserByUserIdRequestSocials
     */
    'instagram'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUpdateUserByUserIdRequestSocials
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUpdateUserByUserIdRequestSocials
     */
    'behance'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUpdateUserByUserIdRequestSocials
     */
    'website'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserControllerUpdateUserByUserIdRequestSocials
     */
    'links'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserControllerUserNameExists200Response
 */
export interface UserControllerUserNameExists200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UserControllerUserNameExists200Response
     */
    'duplicate'?: boolean;
}
/**
 * 
 * @export
 * @interface UserControllerUserNameExists500Response
 */
export interface UserControllerUserNameExists500Response {
    /**
     * 
     * @type {number}
     * @memberof UserControllerUserNameExists500Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUserNameExists500Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof UserControllerUserNameExists500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserLangSettingDto
 */
export interface UserLangSettingDto {
    /**
     * 
     * @type {string}
     * @memberof UserLangSettingDto
     */
    'lang'?: UserLangSettingDtoLangEnum;
}

export const UserLangSettingDtoLangEnum = {
    En: 'en',
    Ko: 'ko'
} as const;

export type UserLangSettingDtoLangEnum = typeof UserLangSettingDtoLangEnum[keyof typeof UserLangSettingDtoLangEnum];

/**
 * 
 * @export
 * @interface UserSettingDto
 */
export interface UserSettingDto {
    /**
     * 
     * @type {string}
     * @memberof UserSettingDto
     */
    'type'?: UserSettingDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserSettingDto
     */
    'subtype'?: UserSettingDtoSubtypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserSettingDto
     */
    'key'?: UserSettingDtoKeyEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettingDto
     */
    'value'?: boolean;
}

export const UserSettingDtoTypeEnum = {
    Privacy: 'privacy',
    Security: 'security',
    Notifications: 'notifications'
} as const;

export type UserSettingDtoTypeEnum = typeof UserSettingDtoTypeEnum[keyof typeof UserSettingDtoTypeEnum];
export const UserSettingDtoSubtypeEnum = {
    AllowMentionBy: 'allowMentionBy',
    NftNotificationsOn: 'nftNotificationsOn'
} as const;

export type UserSettingDtoSubtypeEnum = typeof UserSettingDtoSubtypeEnum[keyof typeof UserSettingDtoSubtypeEnum];
export const UserSettingDtoKeyEnum = {
    ShowPost: 'showPost',
    ShowStory: 'showStory',
    ShowLikesNumber: 'showLikesNumber',
    ShowCommentsNumber: 'showCommentsNumber',
    IsProfilePrivate: 'isProfilePrivate',
    AllUsers: 'allUsers',
    Followers: 'followers',
    NoOne: 'noOne',
    TwoFactorAuth: 'twoFactorAuth',
    GoogleAuthenticator: 'googleAuthenticator',
    AllowPush: 'allowPush',
    PostComments: 'postComments',
    PostLikes: 'postLikes',
    ReplyOnStory: 'replyOnStory',
    LikeAndCommentOnPhoto: 'likeAndCommentOnPhoto',
    NewFollowers: 'newFollowers',
    AcceptedFollowRequests: 'acceptedFollowRequests',
    Sales: 'sales',
    SuccessfulBid: 'successfulBid',
    BidsAndOutBids: 'bidsAndOutBids',
    ExpiredBids: 'expiredBids',
    SuggestedDrops: 'suggestedDrops'
} as const;

export type UserSettingDtoKeyEnum = typeof UserSettingDtoKeyEnum[keyof typeof UserSettingDtoKeyEnum];

/**
 * 
 * @export
 * @interface ValidEmailDto
 */
export interface ValidEmailDto {
    /**
     * 
     * @type {string}
     * @memberof ValidEmailDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface WithdrawalConfirmDto
 */
export interface WithdrawalConfirmDto {
    /**
     * amount
     * @type {number}
     * @memberof WithdrawalConfirmDto
     */
    'otp'?: number;
}
/**
 * 
 * @export
 * @interface WithdrawalControllerWithdrawalConfirm400Response
 */
export interface WithdrawalControllerWithdrawalConfirm400Response {
    /**
     * 
     * @type {number}
     * @memberof WithdrawalControllerWithdrawalConfirm400Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalControllerWithdrawalConfirm400Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalControllerWithdrawalConfirm400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface WithdrawalRequestDto
 */
export interface WithdrawalRequestDto {
    /**
     * amount
     * @type {number}
     * @memberof WithdrawalRequestDto
     */
    'amount'?: number;
    /**
     * currency
     * @type {string}
     * @memberof WithdrawalRequestDto
     */
    'currency'?: string;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {ActivityControllerGetAllActivitiesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityControllerGetAllActivities: async (limit?: number, offset?: number, sortCol?: string, sortDir?: ActivityControllerGetAllActivitiesSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {ActivityControllerGetAllActivitiesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityControllerGetAllActivities(limit?: number, offset?: number, sortCol?: string, sortDir?: ActivityControllerGetAllActivitiesSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityControllerGetAllActivities(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.activityControllerGetAllActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {ActivityControllerGetAllActivitiesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityControllerGetAllActivities(limit?: number, offset?: number, sortCol?: string, sortDir?: ActivityControllerGetAllActivitiesSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<void> {
            return localVarFp.activityControllerGetAllActivities(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {ActivityControllerGetAllActivitiesSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public activityControllerGetAllActivities(limit?: number, offset?: number, sortCol?: string, sortDir?: ActivityControllerGetAllActivitiesSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).activityControllerGetAllActivities(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ActivityControllerGetAllActivitiesSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type ActivityControllerGetAllActivitiesSortDirEnum = typeof ActivityControllerGetAllActivitiesSortDirEnum[keyof typeof ActivityControllerGetAllActivitiesSortDirEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      This API is to verify user\'s email using activation OTP sent via email.
         * @summary 
         * @param {ActivateDto} activateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerActivateUser: async (activateDto: ActivateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activateDto' is not null or undefined
            assertParamExists('authControllerActivateUser', 'activateDto', activateDto)
            const localVarPath = `/v1/auth/activateUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to facilitate google login. Device Details are not required for Web users.
         * @summary 
         * @param {GoogleLoginDto} googleLoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleSignIn: async (googleLoginDto: GoogleLoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'googleLoginDto' is not null or undefined
            assertParamExists('authControllerGoogleSignIn', 'googleLoginDto', googleLoginDto)
            const localVarPath = `/v1/auth/signin/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleLoginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to facilitate instagram login. Device Details are not required for Web users.
         * @summary 
         * @param {InstagramLoginDto} instagramLoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInstagramSignIn: async (instagramLoginDto: InstagramLoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instagramLoginDto' is not null or undefined
            assertParamExists('authControllerInstagramSignIn', 'instagramLoginDto', instagramLoginDto)
            const localVarPath = `/v1/auth/signin/instagram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instagramLoginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for user logout
         * @summary 
         * @param {LogoutDto} logoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (logoutDto: LogoutDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logoutDto' is not null or undefined
            assertParamExists('authControllerLogout', 'logoutDto', logoutDto)
            const localVarPath = `/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for refresh access token
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for sending instructions to the user to reset his password.
         * @summary 
         * @param {ValidEmailDto} validEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestPasswordReset: async (validEmailDto: ValidEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validEmailDto' is not null or undefined
            assertParamExists('authControllerRequestPasswordReset', 'validEmailDto', validEmailDto)
            const localVarPath = `/v1/auth/requestPasswordReset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for resending the activation email to the user incase it is not delivered at signup.
         * @summary 
         * @param {ValidEmailDto} validEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResendVerificationEmail: async (validEmailDto: ValidEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validEmailDto' is not null or undefined
            assertParamExists('authControllerResendVerificationEmail', 'validEmailDto', validEmailDto)
            const localVarPath = `/v1/auth/resendVerificationEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for updating the new password.
         * @summary 
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordDto: ResetPasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordDto' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordDto', resetPasswordDto)
            const localVarPath = `/v1/auth/resetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to facilitate user login. Device Details are not required for Web users.
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerSignIn', 'loginDto', loginDto)
            const localVarPath = `/v1/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for onboarding new user.
         * @summary 
         * @param {NewUserDTO} newUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup: async (newUserDTO: NewUserDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newUserDTO' is not null or undefined
            assertParamExists('authControllerSignup', 'newUserDTO', newUserDTO)
            const localVarPath = `/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUserDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         *      This API is to verify user\'s email using activation OTP sent via email.
         * @summary 
         * @param {ActivateDto} activateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerActivateUser(activateDto: ActivateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerActivateUser(activateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerActivateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to facilitate google login. Device Details are not required for Web users.
         * @summary 
         * @param {GoogleLoginDto} googleLoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGoogleSignIn(googleLoginDto: GoogleLoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignIn200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGoogleSignIn(googleLoginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGoogleSignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to facilitate instagram login. Device Details are not required for Web users.
         * @summary 
         * @param {InstagramLoginDto} instagramLoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerInstagramSignIn(instagramLoginDto: InstagramLoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignIn200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerInstagramSignIn(instagramLoginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerInstagramSignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for user logout
         * @summary 
         * @param {LogoutDto} logoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(logoutDto: LogoutDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(logoutDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for refresh access token
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerRefreshToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for sending instructions to the user to reset his password.
         * @summary 
         * @param {ValidEmailDto} validEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRequestPasswordReset(validEmailDto: ValidEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRequestPasswordReset(validEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRequestPasswordReset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for resending the activation email to the user incase it is not delivered at signup.
         * @summary 
         * @param {ValidEmailDto} validEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResendVerificationEmail(validEmailDto: ValidEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResendVerificationEmail(validEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for updating the new password.
         * @summary 
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to facilitate user login. Device Details are not required for Web users.
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignIn(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignIn200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignIn(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for onboarding new user.
         * @summary 
         * @param {NewUserDTO} newUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignup(newUserDTO: NewUserDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignup(newUserDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         *      This API is to verify user\'s email using activation OTP sent via email.
         * @summary 
         * @param {ActivateDto} activateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerActivateUser(activateDto: ActivateDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.authControllerActivateUser(activateDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to facilitate google login. Device Details are not required for Web users.
         * @summary 
         * @param {GoogleLoginDto} googleLoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleSignIn(googleLoginDto: GoogleLoginDto, options?: any): AxiosPromise<AuthControllerSignIn200Response> {
            return localVarFp.authControllerGoogleSignIn(googleLoginDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to facilitate instagram login. Device Details are not required for Web users.
         * @summary 
         * @param {InstagramLoginDto} instagramLoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInstagramSignIn(instagramLoginDto: InstagramLoginDto, options?: any): AxiosPromise<AuthControllerSignIn200Response> {
            return localVarFp.authControllerInstagramSignIn(instagramLoginDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for user logout
         * @summary 
         * @param {LogoutDto} logoutDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(logoutDto: LogoutDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.authControllerLogout(logoutDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for refresh access token
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(options?: any): AxiosPromise<AuthControllerRefreshToken200Response> {
            return localVarFp.authControllerRefreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for sending instructions to the user to reset his password.
         * @summary 
         * @param {ValidEmailDto} validEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestPasswordReset(validEmailDto: ValidEmailDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.authControllerRequestPasswordReset(validEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for resending the activation email to the user incase it is not delivered at signup.
         * @summary 
         * @param {ValidEmailDto} validEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResendVerificationEmail(validEmailDto: ValidEmailDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.authControllerResendVerificationEmail(validEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for updating the new password.
         * @summary 
         * @param {ResetPasswordDto} resetPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.authControllerResetPassword(resetPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to facilitate user login. Device Details are not required for Web users.
         * @summary 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn(loginDto: LoginDto, options?: any): AxiosPromise<AuthControllerSignIn200Response> {
            return localVarFp.authControllerSignIn(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for onboarding new user.
         * @summary 
         * @param {NewUserDTO} newUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignup(newUserDTO: NewUserDTO, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.authControllerSignup(newUserDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     *      This API is to verify user\'s email using activation OTP sent via email.
     * @summary 
     * @param {ActivateDto} activateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerActivateUser(activateDto: ActivateDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerActivateUser(activateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to facilitate google login. Device Details are not required for Web users.
     * @summary 
     * @param {GoogleLoginDto} googleLoginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGoogleSignIn(googleLoginDto: GoogleLoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGoogleSignIn(googleLoginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to facilitate instagram login. Device Details are not required for Web users.
     * @summary 
     * @param {InstagramLoginDto} instagramLoginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerInstagramSignIn(instagramLoginDto: InstagramLoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerInstagramSignIn(instagramLoginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for user logout
     * @summary 
     * @param {LogoutDto} logoutDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogout(logoutDto: LogoutDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogout(logoutDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for refresh access token
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshToken(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for sending instructions to the user to reset his password.
     * @summary 
     * @param {ValidEmailDto} validEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRequestPasswordReset(validEmailDto: ValidEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRequestPasswordReset(validEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for resending the activation email to the user incase it is not delivered at signup.
     * @summary 
     * @param {ValidEmailDto} validEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResendVerificationEmail(validEmailDto: ValidEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResendVerificationEmail(validEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for updating the new password.
     * @summary 
     * @param {ResetPasswordDto} resetPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPassword(resetPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to facilitate user login. Device Details are not required for Web users.
     * @summary 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignIn(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignIn(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for onboarding new user.
     * @summary 
     * @param {NewUserDTO} newUserDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignup(newUserDTO: NewUserDTO, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignup(newUserDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate: async (createCategoryDto: CreateCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCategoryDto' is not null or undefined
            assertParamExists('categoryControllerCreate', 'createCategoryDto', createCategoryDto)
            const localVarPath = `/v1/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteCategoryDto} deleteCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerDeleteCategory: async (deleteCategoryDto: DeleteCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteCategoryDto' is not null or undefined
            assertParamExists('categoryControllerDeleteCategory', 'deleteCategoryDto', deleteCategoryDto)
            const localVarPath = `/v1/category/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerGetCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerCreate(createCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteCategoryDto} deleteCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerDeleteCategory(deleteCategoryDto: DeleteCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerDeleteCategory(deleteCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryControllerDeleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryControllerGetCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryControllerGetCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryControllerGetCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.categoryControllerGetCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCategoryDto} createCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: any): AxiosPromise<CategoryControllerCreate200Response> {
            return localVarFp.categoryControllerCreate(createCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteCategoryDto} deleteCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerDeleteCategory(deleteCategoryDto: DeleteCategoryDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.categoryControllerDeleteCategory(deleteCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryControllerGetCategories(options?: any): AxiosPromise<CategoryControllerGetCategories200Response> {
            return localVarFp.categoryControllerGetCategories(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @param {CreateCategoryDto} createCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryControllerCreate(createCategoryDto: CreateCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryControllerCreate(createCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteCategoryDto} deleteCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryControllerDeleteCategory(deleteCategoryDto: DeleteCategoryDto, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryControllerDeleteCategory(deleteCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryControllerGetCategories(options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).categoryControllerGetCategories(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactUsApi - axios parameter creator
 * @export
 */
export const ContactUsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      This API is for Saving the information from contact us form in the database.     It takes Contacter Details, his/her issue and description of his concern and saves it in the database.     It return the saved contact Us form details if no error or exception occurs
         * @summary 
         * @param {ContactUsDto} contactUsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUsControllerPostContact: async (contactUsDto: ContactUsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactUsDto' is not null or undefined
            assertParamExists('contactUsControllerPostContact', 'contactUsDto', contactUsDto)
            const localVarPath = `/v1/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactUsApi - functional programming interface
 * @export
 */
export const ContactUsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactUsApiAxiosParamCreator(configuration)
    return {
        /**
         *      This API is for Saving the information from contact us form in the database.     It takes Contacter Details, his/her issue and description of his concern and saves it in the database.     It return the saved contact Us form details if no error or exception occurs
         * @summary 
         * @param {ContactUsDto} contactUsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactUsControllerPostContact(contactUsDto: ContactUsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactUsControllerPostContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactUsControllerPostContact(contactUsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactUsApi.contactUsControllerPostContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactUsApi - factory interface
 * @export
 */
export const ContactUsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactUsApiFp(configuration)
    return {
        /**
         *      This API is for Saving the information from contact us form in the database.     It takes Contacter Details, his/her issue and description of his concern and saves it in the database.     It return the saved contact Us form details if no error or exception occurs
         * @summary 
         * @param {ContactUsDto} contactUsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactUsControllerPostContact(contactUsDto: ContactUsDto, options?: any): AxiosPromise<ContactUsControllerPostContact200Response> {
            return localVarFp.contactUsControllerPostContact(contactUsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactUsApi - object-oriented interface
 * @export
 * @class ContactUsApi
 * @extends {BaseAPI}
 */
export class ContactUsApi extends BaseAPI {
    /**
     *      This API is for Saving the information from contact us form in the database.     It takes Contacter Details, his/her issue and description of his concern and saves it in the database.     It return the saved contact Us form details if no error or exception occurs
     * @summary 
     * @param {ContactUsDto} contactUsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactUsApi
     */
    public contactUsControllerPostContact(contactUsDto: ContactUsDto, options?: RawAxiosRequestConfig) {
        return ContactUsApiFp(this.configuration).contactUsControllerPostContact(contactUsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConversationApi - axios parameter creator
 * @export
 */
export const ConversationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeleteChatDto} deleteChatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationControllerDeleteChat: async (deleteChatDto: DeleteChatDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteChatDto' is not null or undefined
            assertParamExists('conversationControllerDeleteChat', 'deleteChatDto', deleteChatDto)
            const localVarPath = `/v1/chats/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteChatDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {ConversationControllerGetAllChatsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationControllerGetAllChats: async (limit?: number, offset?: number, sortCol?: string, sortDir?: ConversationControllerGetAllChatsSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationApi - functional programming interface
 * @export
 */
export const ConversationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeleteChatDto} deleteChatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationControllerDeleteChat(deleteChatDto: DeleteChatDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationControllerDeleteChat(deleteChatDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.conversationControllerDeleteChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {ConversationControllerGetAllChatsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationControllerGetAllChats(limit?: number, offset?: number, sortCol?: string, sortDir?: ConversationControllerGetAllChatsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseConversationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationControllerGetAllChats(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationApi.conversationControllerGetAllChats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationApi - factory interface
 * @export
 */
export const ConversationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationApiFp(configuration)
    return {
        /**
         * 
         * @param {DeleteChatDto} deleteChatDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationControllerDeleteChat(deleteChatDto: DeleteChatDto, options?: any): AxiosPromise<void> {
            return localVarFp.conversationControllerDeleteChat(deleteChatDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {ConversationControllerGetAllChatsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationControllerGetAllChats(limit?: number, offset?: number, sortCol?: string, sortDir?: ConversationControllerGetAllChatsSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<ResponseConversationDto> {
            return localVarFp.conversationControllerGetAllChats(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationApi - object-oriented interface
 * @export
 * @class ConversationApi
 * @extends {BaseAPI}
 */
export class ConversationApi extends BaseAPI {
    /**
     * 
     * @param {DeleteChatDto} deleteChatDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public conversationControllerDeleteChat(deleteChatDto: DeleteChatDto, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).conversationControllerDeleteChat(deleteChatDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {ConversationControllerGetAllChatsSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApi
     */
    public conversationControllerGetAllChats(limit?: number, offset?: number, sortCol?: string, sortDir?: ConversationControllerGetAllChatsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return ConversationApiFp(this.configuration).conversationControllerGetAllChats(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ConversationControllerGetAllChatsSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type ConversationControllerGetAllChatsSortDirEnum = typeof ConversationControllerGetAllChatsSortDirEnum[keyof typeof ConversationControllerGetAllChatsSortDirEnum];


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetActiveUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/app/activeUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetAppSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/app/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/app`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketControllerGetAssets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/market/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketControllerGetCollections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/market/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetActiveUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetActiveUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appControllerGetActiveUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetAppSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetAppSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appControllerGetAppSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketControllerGetAssets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketControllerGetAssets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.marketControllerGetAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketControllerGetCollections(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketControllerGetCollections(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.marketControllerGetCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetActiveUsers(options?: any): AxiosPromise<number> {
            return localVarFp.appControllerGetActiveUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetAppSettings(options?: any): AxiosPromise<void> {
            return localVarFp.appControllerGetAppSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: any): AxiosPromise<string> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketControllerGetAssets(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.marketControllerGetAssets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketControllerGetCollections(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.marketControllerGetCollections(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetActiveUsers(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetActiveUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetAppSettings(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetAppSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public marketControllerGetAssets(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).marketControllerGetAssets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public marketControllerGetCollections(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).marketControllerGetCollections(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FAQsApi - axios parameter creator
 * @export
 */
export const FAQsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      This API is for creating a new FAQ.     It takes Question, Answer and Category of the FAQ as request body.     It returns newly created object if no error or exception occurs.
         * @summary 
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerCreateFaq: async (createFaqDto: CreateFaqDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFaqDto' is not null or undefined
            assertParamExists('faqsControllerCreateFaq', 'createFaqDto', createFaqDto)
            const localVarPath = `/v1/faqs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFaqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for deleting an existing FAQ from the database.     It takes FAQ id as request params and delete it.     If no error or exception occurs then it will return success response.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerDeleteFaq: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('faqsControllerDeleteFaq', 'id', id)
            const localVarPath = `/v1/faqs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting one faq by its id.     It takes Id from request parameters.     If no error or exception occue then it will return the faq object containg question, answer and category
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerGetFaqById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('faqsControllerGetFaqById', 'id', id)
            const localVarPath = `/v1/faqs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting all the FAQ\'s from the databse.     If no error or exception occur then it returns the array of documents of FAQ\'s
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {FaqsControllerGetFaqsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerGetFaqs: async (limit?: number, offset?: number, sortCol?: string, sortDir?: FaqsControllerGetFaqsSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/faqs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for updating an existing FAQ by its id.     It takes FAQ id as request parameters.     It takes updated properties of the FAQ as the request body.     If no error or exception occur then it returns the updated FAQ.
         * @summary 
         * @param {string} id 
         * @param {UpdateFaqDto} updateFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerUpdateFaq: async (id: string, updateFaqDto: UpdateFaqDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('faqsControllerUpdateFaq', 'id', id)
            // verify required parameter 'updateFaqDto' is not null or undefined
            assertParamExists('faqsControllerUpdateFaq', 'updateFaqDto', updateFaqDto)
            const localVarPath = `/v1/faqs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFaqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FAQsApi - functional programming interface
 * @export
 */
export const FAQsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FAQsApiAxiosParamCreator(configuration)
    return {
        /**
         *      This API is for creating a new FAQ.     It takes Question, Answer and Category of the FAQ as request body.     It returns newly created object if no error or exception occurs.
         * @summary 
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqsControllerCreateFaq(createFaqDto: CreateFaqDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqsControllerGetFaqs200ResponseFaqsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqsControllerCreateFaq(createFaqDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FAQsApi.faqsControllerCreateFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for deleting an existing FAQ from the database.     It takes FAQ id as request params and delete it.     If no error or exception occurs then it will return success response.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqsControllerDeleteFaq(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqsControllerDeleteFaq(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FAQsApi.faqsControllerDeleteFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting one faq by its id.     It takes Id from request parameters.     If no error or exception occue then it will return the faq object containg question, answer and category
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqsControllerGetFaqById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqsControllerGetFaqs200ResponseFaqsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqsControllerGetFaqById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FAQsApi.faqsControllerGetFaqById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting all the FAQ\'s from the databse.     If no error or exception occur then it returns the array of documents of FAQ\'s
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {FaqsControllerGetFaqsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqsControllerGetFaqs(limit?: number, offset?: number, sortCol?: string, sortDir?: FaqsControllerGetFaqsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqsControllerGetFaqs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqsControllerGetFaqs(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FAQsApi.faqsControllerGetFaqs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for updating an existing FAQ by its id.     It takes FAQ id as request parameters.     It takes updated properties of the FAQ as the request body.     If no error or exception occur then it returns the updated FAQ.
         * @summary 
         * @param {string} id 
         * @param {UpdateFaqDto} updateFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqsControllerUpdateFaq(id: string, updateFaqDto: UpdateFaqDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqsControllerGetFaqs200ResponseFaqsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqsControllerUpdateFaq(id, updateFaqDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FAQsApi.faqsControllerUpdateFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FAQsApi - factory interface
 * @export
 */
export const FAQsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FAQsApiFp(configuration)
    return {
        /**
         *      This API is for creating a new FAQ.     It takes Question, Answer and Category of the FAQ as request body.     It returns newly created object if no error or exception occurs.
         * @summary 
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerCreateFaq(createFaqDto: CreateFaqDto, options?: any): AxiosPromise<FaqsControllerGetFaqs200ResponseFaqsInner> {
            return localVarFp.faqsControllerCreateFaq(createFaqDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for deleting an existing FAQ from the database.     It takes FAQ id as request params and delete it.     If no error or exception occurs then it will return success response.
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerDeleteFaq(id: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.faqsControllerDeleteFaq(id, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting one faq by its id.     It takes Id from request parameters.     If no error or exception occue then it will return the faq object containg question, answer and category
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerGetFaqById(id: string, options?: any): AxiosPromise<FaqsControllerGetFaqs200ResponseFaqsInner> {
            return localVarFp.faqsControllerGetFaqById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting all the FAQ\'s from the databse.     If no error or exception occur then it returns the array of documents of FAQ\'s
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {FaqsControllerGetFaqsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerGetFaqs(limit?: number, offset?: number, sortCol?: string, sortDir?: FaqsControllerGetFaqsSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<FaqsControllerGetFaqs200Response> {
            return localVarFp.faqsControllerGetFaqs(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for updating an existing FAQ by its id.     It takes FAQ id as request parameters.     It takes updated properties of the FAQ as the request body.     If no error or exception occur then it returns the updated FAQ.
         * @summary 
         * @param {string} id 
         * @param {UpdateFaqDto} updateFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqsControllerUpdateFaq(id: string, updateFaqDto: UpdateFaqDto, options?: any): AxiosPromise<FaqsControllerGetFaqs200ResponseFaqsInner> {
            return localVarFp.faqsControllerUpdateFaq(id, updateFaqDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FAQsApi - object-oriented interface
 * @export
 * @class FAQsApi
 * @extends {BaseAPI}
 */
export class FAQsApi extends BaseAPI {
    /**
     *      This API is for creating a new FAQ.     It takes Question, Answer and Category of the FAQ as request body.     It returns newly created object if no error or exception occurs.
     * @summary 
     * @param {CreateFaqDto} createFaqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsApi
     */
    public faqsControllerCreateFaq(createFaqDto: CreateFaqDto, options?: RawAxiosRequestConfig) {
        return FAQsApiFp(this.configuration).faqsControllerCreateFaq(createFaqDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for deleting an existing FAQ from the database.     It takes FAQ id as request params and delete it.     If no error or exception occurs then it will return success response.
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsApi
     */
    public faqsControllerDeleteFaq(id: string, options?: RawAxiosRequestConfig) {
        return FAQsApiFp(this.configuration).faqsControllerDeleteFaq(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting one faq by its id.     It takes Id from request parameters.     If no error or exception occue then it will return the faq object containg question, answer and category
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsApi
     */
    public faqsControllerGetFaqById(id: string, options?: RawAxiosRequestConfig) {
        return FAQsApiFp(this.configuration).faqsControllerGetFaqById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting all the FAQ\'s from the databse.     If no error or exception occur then it returns the array of documents of FAQ\'s
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {FaqsControllerGetFaqsSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsApi
     */
    public faqsControllerGetFaqs(limit?: number, offset?: number, sortCol?: string, sortDir?: FaqsControllerGetFaqsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return FAQsApiFp(this.configuration).faqsControllerGetFaqs(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for updating an existing FAQ by its id.     It takes FAQ id as request parameters.     It takes updated properties of the FAQ as the request body.     If no error or exception occur then it returns the updated FAQ.
     * @summary 
     * @param {string} id 
     * @param {UpdateFaqDto} updateFaqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsApi
     */
    public faqsControllerUpdateFaq(id: string, updateFaqDto: UpdateFaqDto, options?: RawAxiosRequestConfig) {
        return FAQsApiFp(this.configuration).faqsControllerUpdateFaq(id, updateFaqDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FaqsControllerGetFaqsSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type FaqsControllerGetFaqsSortDirEnum = typeof FaqsControllerGetFaqsSortDirEnum[keyof typeof FaqsControllerGetFaqsSortDirEnum];


/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      This API is for adding comment on a post.     PostID is provided to this API as request parameter.     Comment text it takes in request body.     If no error or exception occur the this API will add comment in the post and return the newly created comment.
         * @summary 
         * @param {string} postId 
         * @param {CommentDataDto} commentDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerAddComment: async (postId: string, commentDataDto: CommentDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerAddComment', 'postId', postId)
            // verify required parameter 'commentDataDto' is not null or undefined
            assertParamExists('postControllerAddComment', 'commentDataDto', commentDataDto)
            const localVarPath = `/v1/posts/comment/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for adding or removing the post into the or from the user favourites respectively.     If Post is Already in favouites of the user then it will remove it from the favourites.     If Post is not Already in favourites of the user then it will add it into the favourites.     it takes postId as the request parameter.     It will return success if no error or exception occurs.
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerAddOrRemoveToOrFromFavourites: async (postId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerAddOrRemoveToOrFromFavourites', 'postId', postId)
            const localVarPath = `/v1/posts/favourite/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for creating a draft.     Consumes multi-part form data for creating Draft.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Returns the updated post if no error or exception occur.
         * @summary 
         * @param {string} [postId] Post id
         * @param {Array<File>} [file] images/videos
         * @param {Array<string>} [tags] tags
         * @param {string} [category] category
         * @param {string} [description] description
         * @param {PostControllerCreateDraftIsPrivateEnum} [isPrivate] isPrivate
         * @param {PostControllerCreateDraftIsBlurEnum} [isBlur] isBlur
         * @param {PostControllerCreateDraftIsFixedPriceEnum} [isFixedPrice] isFixedPrice
         * @param {number} [price] price
         * @param {string} [tierId] tierId
         * @param {PostControllerCreateDraftIsScheduledEnum} [isScheduled] isScheduled
         * @param {string} [date] date
         * @param {PostControllerCreateDraftIsLocationEnum} [isLocation] isLocation
         * @param {LocationDto} [location] location
         * @param {PostControllerCreateDraftIsAdultContentEnum} [isAdultContent] isAdultContent
         * @param {PostControllerCreateDraftIsDraftEnum} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerCreateDraft: async (postId?: string, file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreateDraftIsPrivateEnum, isBlur?: PostControllerCreateDraftIsBlurEnum, isFixedPrice?: PostControllerCreateDraftIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreateDraftIsScheduledEnum, date?: string, isLocation?: PostControllerCreateDraftIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreateDraftIsAdultContentEnum, isDraft?: PostControllerCreateDraftIsDraftEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/posts/draft`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (postId !== undefined) { 
                localVarFormParams.append('postId', postId as any);
            }
                if (file) {
                file.forEach((element) => {
                    localVarFormParams.append('file', element as any);
                })
            }

                if (tags) {
                localVarFormParams.append('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (isPrivate !== undefined) { 
                localVarFormParams.append('isPrivate', isPrivate as any);
            }
    
            if (isBlur !== undefined) { 
                localVarFormParams.append('isBlur', isBlur as any);
            }
    
            if (isFixedPrice !== undefined) { 
                localVarFormParams.append('isFixedPrice', isFixedPrice as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (tierId !== undefined) { 
                localVarFormParams.append('tierId', tierId as any);
            }
    
            if (isScheduled !== undefined) { 
                localVarFormParams.append('isScheduled', isScheduled as any);
            }
    
            if (date !== undefined) { 
                localVarFormParams.append('date', date as any);
            }
    
            if (isLocation !== undefined) { 
                localVarFormParams.append('isLocation', isLocation as any);
            }
    
            if (location !== undefined) { 
                localVarFormParams.append('location', new Blob([JSON.stringify(location)], { type: "application/json", }));
            }
    
            if (isAdultContent !== undefined) { 
                localVarFormParams.append('isAdultContent', isAdultContent as any);
            }
    
            if (isDraft !== undefined) { 
                localVarFormParams.append('isDraft', isDraft as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for creating a new post.     Consumes multi-part form data for creating POST.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Either at least One Media File or Description is Required or Both     Returns the newly created post if no error or exception occur.     This API also can save the post as draft and whenever drafts post is edited and saved as new post the same API can do this work.
         * @summary 
         * @param {Array<File>} [file] images/videos
         * @param {Array<string>} [tags] tags
         * @param {string} [category] category
         * @param {string} [description] description
         * @param {PostControllerCreatePostIsPrivateEnum} [isPrivate] isPrivate
         * @param {PostControllerCreatePostIsBlurEnum} [isBlur] isBlur
         * @param {PostControllerCreatePostIsFixedPriceEnum} [isFixedPrice] isFixedPrice
         * @param {number} [price] price
         * @param {string} [tierId] tierId
         * @param {PostControllerCreatePostIsScheduledEnum} [isScheduled] isScheduled
         * @param {string} [date] date
         * @param {PostControllerCreatePostIsLocationEnum} [isLocation] isLocation
         * @param {LocationDto} [location] location
         * @param {PostControllerCreatePostIsAdultContentEnum} [isAdultContent] isAdultContent
         * @param {PostControllerCreatePostIsDraftEnum} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerCreatePost: async (file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreatePostIsPrivateEnum, isBlur?: PostControllerCreatePostIsBlurEnum, isFixedPrice?: PostControllerCreatePostIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreatePostIsScheduledEnum, date?: string, isLocation?: PostControllerCreatePostIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreatePostIsAdultContentEnum, isDraft?: PostControllerCreatePostIsDraftEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (file) {
                file.forEach((element) => {
                    localVarFormParams.append('file', element as any);
                })
            }

                if (tags) {
                localVarFormParams.append('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (isPrivate !== undefined) { 
                localVarFormParams.append('isPrivate', isPrivate as any);
            }
    
            if (isBlur !== undefined) { 
                localVarFormParams.append('isBlur', isBlur as any);
            }
    
            if (isFixedPrice !== undefined) { 
                localVarFormParams.append('isFixedPrice', isFixedPrice as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (tierId !== undefined) { 
                localVarFormParams.append('tierId', tierId as any);
            }
    
            if (isScheduled !== undefined) { 
                localVarFormParams.append('isScheduled', isScheduled as any);
            }
    
            if (date !== undefined) { 
                localVarFormParams.append('date', date as any);
            }
    
            if (isLocation !== undefined) { 
                localVarFormParams.append('isLocation', isLocation as any);
            }
    
            if (location !== undefined) { 
                localVarFormParams.append('location', new Blob([JSON.stringify(location)], { type: "application/json", }));
            }
    
            if (isAdultContent !== undefined) { 
                localVarFormParams.append('isAdultContent', isAdultContent as any);
            }
    
            if (isDraft !== undefined) { 
                localVarFormParams.append('isDraft', isDraft as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for deleting a comment from the existing post.     If no error or exception occur then it will delete the comment from the API.          Need to be updated later.
         * @summary 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerDeleteComment: async (commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('postControllerDeleteComment', 'commentId', commentId)
            const localVarPath = `/v1/posts/comment/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for deleting a draft by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the draft all media files from the S3 storage
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerDeleteDraft: async (postId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerDeleteDraft', 'postId', postId)
            const localVarPath = `/v1/posts/draft/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for deleting a post by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the post all media files from the S3 storage
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerDeletePost: async (postId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerDeletePost', 'postId', postId)
            const localVarPath = `/v1/posts/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This Api is for getting all the posts in the drafts of logged in User.     Returns the array of objects of drafts if no error or Exception Occurs
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetAllDrafts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/posts/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting all the Posts in the database that are recommended for the user who is logged In.     It returns an object containing the array of recommended/related posts according to the limit and offset in the optional query params     and total count of post that are recommended/related
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetAllRecommendedPostsForFeedSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetAllRecommendedPostsForFeed: async (limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetAllRecommendedPostsForFeedSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting One Post by its Id provided as the request parameter.     If the posts with this Id exists and no error or exception occurs then it returns the details required for this post as a document.
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostById: async (postId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerGetPostById', 'postId', postId)
            const localVarPath = `/v1/posts/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        This API for get post data and comment data by postId And commentId.      
         * @summary 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostByIdAndCommentDataSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostByIdAndCommentData: async (postId: string, commentId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostByIdAndCommentDataSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerGetPostByIdAndCommentData', 'postId', postId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('postControllerGetPostByIdAndCommentData', 'commentId', commentId)
            const localVarPath = `/v1/posts/{postId}/{commentId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} postId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostCommentsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostComments: async (postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostCommentsSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerGetPostComments', 'postId', postId)
            const localVarPath = `/v1/posts/comments/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This Api is for getting all the likes for a postId and postId provided as the request parameter.
         * @summary 
         * @param {string} postId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostLikesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostLikes: async (postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostLikesSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerGetPostLikes', 'postId', postId)
            const localVarPath = `/v1/posts/likes/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetUsersCollaboratorsPostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetUsersCollaboratorsPosts: async (userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersCollaboratorsPostsSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('postControllerGetUsersCollaboratorsPosts', 'userId', userId)
            const localVarPath = `/v1/posts/collaborators/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetUsersFavouritePostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetUsersFavouritePosts: async (limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersFavouritePostsSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/posts/myFavourites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for liking the post.     The postId it takes with request parameter and add the logged in userId in the likes List if not already liked the post     Also Create Activity of liking the post
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerLikePost: async (postId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerLikePost', 'postId', postId)
            const localVarPath = `/v1/posts/like/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for unliking the post.     The postId it takes with request parameter and remove the logged in userId in the likes List if already liked the post.     
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerUnlikePost: async (postId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerUnlikePost', 'postId', postId)
            const localVarPath = `/v1/posts/unlike/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        This API updates the comments whose Id it takes as request body.       All Properties in request body are optional and provided properties will be updated in the database.      
         * @summary 
         * @param {string} commentId 
         * @param {UpdateCommentDto} updateCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerUpdateComment: async (commentId: string, updateCommentDto: UpdateCommentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('postControllerUpdateComment', 'commentId', commentId)
            // verify required parameter 'updateCommentDto' is not null or undefined
            assertParamExists('postControllerUpdateComment', 'updateCommentDto', updateCommentDto)
            const localVarPath = `/v1/posts/comment/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCommentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API updates the post whose Id it takes as request body.     All Properties in request body are optional and provided properties will be updated in the database.     if new media is uploaded then it will delete previous media from S3 and upload new data on S3.     Returns the updated Post if no error or exception occurs.      Will Be Updated when Design will be finalized
         * @summary 
         * @param {string} postId 
         * @param {string} [title] title
         * @param {Array<File>} [media] images/videos
         * @param {Array<string>} [tags] tags
         * @param {PostControllerUpdatePostCategoryEnum} [category] category
         * @param {Array<string>} [collaborators] collaborators
         * @param {string} [description] description
         * @param {boolean} [isPrivate] isPrivate
         * @param {boolean} [isBlur] isBlur
         * @param {string} [tierId] tierId
         * @param {boolean} [isScheduled] isScheduled
         * @param {number} [price] price
         * @param {string} [date] date
         * @param {string} [time] time
         * @param {boolean} [isLocation] isLocation
         * @param {boolean} [isAdultContent] isAdultContent
         * @param {boolean} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerUpdatePost: async (postId: string, title?: string, media?: Array<File>, tags?: Array<string>, category?: PostControllerUpdatePostCategoryEnum, collaborators?: Array<string>, description?: string, isPrivate?: boolean, isBlur?: boolean, tierId?: string, isScheduled?: boolean, price?: number, date?: string, time?: string, isLocation?: boolean, isAdultContent?: boolean, isDraft?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('postControllerUpdatePost', 'postId', postId)
            const localVarPath = `/v1/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (postId !== undefined) { 
                localVarFormParams.append('postId', postId as any);
            }
    
            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
                if (media) {
                media.forEach((element) => {
                    localVarFormParams.append('media', element as any);
                })
            }

                if (tags) {
                localVarFormParams.append('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
                if (collaborators) {
                localVarFormParams.append('collaborators', collaborators.join(COLLECTION_FORMATS.csv));
            }

    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (isPrivate !== undefined) { 
                localVarFormParams.append('isPrivate', String(isPrivate) as any);
            }
    
            if (isBlur !== undefined) { 
                localVarFormParams.append('isBlur', String(isBlur) as any);
            }
    
            if (tierId !== undefined) { 
                localVarFormParams.append('tierId', tierId as any);
            }
    
            if (isScheduled !== undefined) { 
                localVarFormParams.append('isScheduled', String(isScheduled) as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (date !== undefined) { 
                localVarFormParams.append('date', date as any);
            }
    
            if (time !== undefined) { 
                localVarFormParams.append('time', time as any);
            }
    
            if (isLocation !== undefined) { 
                localVarFormParams.append('isLocation', String(isLocation) as any);
            }
    
            if (isAdultContent !== undefined) { 
                localVarFormParams.append('isAdultContent', String(isAdultContent) as any);
            }
    
            if (isDraft !== undefined) { 
                localVarFormParams.append('isDraft', String(isDraft) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration)
    return {
        /**
         *      This API is for adding comment on a post.     PostID is provided to this API as request parameter.     Comment text it takes in request body.     If no error or exception occur the this API will add comment in the post and return the newly created comment.
         * @summary 
         * @param {string} postId 
         * @param {CommentDataDto} commentDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerAddComment(postId: string, commentDataDto: CommentDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostControllerUpdateComment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerAddComment(postId, commentDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerAddComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for adding or removing the post into the or from the user favourites respectively.     If Post is Already in favouites of the user then it will remove it from the favourites.     If Post is not Already in favourites of the user then it will add it into the favourites.     it takes postId as the request parameter.     It will return success if no error or exception occurs.
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerAddOrRemoveToOrFromFavourites(postId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerAddOrRemoveToOrFromFavourites(postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerAddOrRemoveToOrFromFavourites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for creating a draft.     Consumes multi-part form data for creating Draft.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Returns the updated post if no error or exception occur.
         * @summary 
         * @param {string} [postId] Post id
         * @param {Array<File>} [file] images/videos
         * @param {Array<string>} [tags] tags
         * @param {string} [category] category
         * @param {string} [description] description
         * @param {PostControllerCreateDraftIsPrivateEnum} [isPrivate] isPrivate
         * @param {PostControllerCreateDraftIsBlurEnum} [isBlur] isBlur
         * @param {PostControllerCreateDraftIsFixedPriceEnum} [isFixedPrice] isFixedPrice
         * @param {number} [price] price
         * @param {string} [tierId] tierId
         * @param {PostControllerCreateDraftIsScheduledEnum} [isScheduled] isScheduled
         * @param {string} [date] date
         * @param {PostControllerCreateDraftIsLocationEnum} [isLocation] isLocation
         * @param {LocationDto} [location] location
         * @param {PostControllerCreateDraftIsAdultContentEnum} [isAdultContent] isAdultContent
         * @param {PostControllerCreateDraftIsDraftEnum} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerCreateDraft(postId?: string, file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreateDraftIsPrivateEnum, isBlur?: PostControllerCreateDraftIsBlurEnum, isFixedPrice?: PostControllerCreateDraftIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreateDraftIsScheduledEnum, date?: string, isLocation?: PostControllerCreateDraftIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreateDraftIsAdultContentEnum, isDraft?: PostControllerCreateDraftIsDraftEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerCreateDraft(postId, file, tags, category, description, isPrivate, isBlur, isFixedPrice, price, tierId, isScheduled, date, isLocation, location, isAdultContent, isDraft, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerCreateDraft']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for creating a new post.     Consumes multi-part form data for creating POST.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Either at least One Media File or Description is Required or Both     Returns the newly created post if no error or exception occur.     This API also can save the post as draft and whenever drafts post is edited and saved as new post the same API can do this work.
         * @summary 
         * @param {Array<File>} [file] images/videos
         * @param {Array<string>} [tags] tags
         * @param {string} [category] category
         * @param {string} [description] description
         * @param {PostControllerCreatePostIsPrivateEnum} [isPrivate] isPrivate
         * @param {PostControllerCreatePostIsBlurEnum} [isBlur] isBlur
         * @param {PostControllerCreatePostIsFixedPriceEnum} [isFixedPrice] isFixedPrice
         * @param {number} [price] price
         * @param {string} [tierId] tierId
         * @param {PostControllerCreatePostIsScheduledEnum} [isScheduled] isScheduled
         * @param {string} [date] date
         * @param {PostControllerCreatePostIsLocationEnum} [isLocation] isLocation
         * @param {LocationDto} [location] location
         * @param {PostControllerCreatePostIsAdultContentEnum} [isAdultContent] isAdultContent
         * @param {PostControllerCreatePostIsDraftEnum} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerCreatePost(file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreatePostIsPrivateEnum, isBlur?: PostControllerCreatePostIsBlurEnum, isFixedPrice?: PostControllerCreatePostIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreatePostIsScheduledEnum, date?: string, isLocation?: PostControllerCreatePostIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreatePostIsAdultContentEnum, isDraft?: PostControllerCreatePostIsDraftEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerCreatePost(file, tags, category, description, isPrivate, isBlur, isFixedPrice, price, tierId, isScheduled, date, isLocation, location, isAdultContent, isDraft, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for deleting a comment from the existing post.     If no error or exception occur then it will delete the comment from the API.          Need to be updated later.
         * @summary 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerDeleteComment(commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerDeleteComment(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerDeleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for deleting a draft by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the draft all media files from the S3 storage
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerDeleteDraft(postId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerDeleteDraft(postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerDeleteDraft']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for deleting a post by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the post all media files from the S3 storage
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerDeletePost(postId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerDeletePost(postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This Api is for getting all the posts in the drafts of logged in User.     Returns the array of objects of drafts if no error or Exception Occurs
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetAllDrafts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostControllerGetAllDrafts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetAllDrafts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetAllDrafts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting all the Posts in the database that are recommended for the user who is logged In.     It returns an object containing the array of recommended/related posts according to the limit and offset in the optional query params     and total count of post that are recommended/related
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetAllRecommendedPostsForFeedSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetAllRecommendedPostsForFeed(limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetAllRecommendedPostsForFeedSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetAllRecommendedPostsForFeed(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetAllRecommendedPostsForFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting One Post by its Id provided as the request parameter.     If the posts with this Id exists and no error or exception occurs then it returns the details required for this post as a document.
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetPostById(postId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostControllerGetAllDrafts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetPostById(postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetPostById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        This API for get post data and comment data by postId And commentId.      
         * @summary 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostByIdAndCommentDataSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetPostByIdAndCommentData(postId: string, commentId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostByIdAndCommentDataSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetPostByIdAndCommentData(postId, commentId, limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetPostByIdAndCommentData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} postId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostCommentsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetPostComments(postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostCommentsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetPostComments(postId, limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetPostComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This Api is for getting all the likes for a postId and postId provided as the request parameter.
         * @summary 
         * @param {string} postId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostLikesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetPostLikes(postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostLikesSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetPostLikes(postId, limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetPostLikes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetUsersCollaboratorsPostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetUsersCollaboratorsPosts(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersCollaboratorsPostsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetUsersCollaboratorsPosts(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetUsersCollaboratorsPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetUsersFavouritePostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerGetUsersFavouritePosts(limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersFavouritePostsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerGetUsersFavouritePosts(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerGetUsersFavouritePosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for liking the post.     The postId it takes with request parameter and add the logged in userId in the likes List if not already liked the post     Also Create Activity of liking the post
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerLikePost(postId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerLikePost(postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerLikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for unliking the post.     The postId it takes with request parameter and remove the logged in userId in the likes List if already liked the post.     
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerUnlikePost(postId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerUnlikePost(postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerUnlikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        This API updates the comments whose Id it takes as request body.       All Properties in request body are optional and provided properties will be updated in the database.      
         * @summary 
         * @param {string} commentId 
         * @param {UpdateCommentDto} updateCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerUpdateComment(commentId: string, updateCommentDto: UpdateCommentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostControllerUpdateComment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerUpdateComment(commentId, updateCommentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerUpdateComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API updates the post whose Id it takes as request body.     All Properties in request body are optional and provided properties will be updated in the database.     if new media is uploaded then it will delete previous media from S3 and upload new data on S3.     Returns the updated Post if no error or exception occurs.      Will Be Updated when Design will be finalized
         * @summary 
         * @param {string} postId 
         * @param {string} [title] title
         * @param {Array<File>} [media] images/videos
         * @param {Array<string>} [tags] tags
         * @param {PostControllerUpdatePostCategoryEnum} [category] category
         * @param {Array<string>} [collaborators] collaborators
         * @param {string} [description] description
         * @param {boolean} [isPrivate] isPrivate
         * @param {boolean} [isBlur] isBlur
         * @param {string} [tierId] tierId
         * @param {boolean} [isScheduled] isScheduled
         * @param {number} [price] price
         * @param {string} [date] date
         * @param {string} [time] time
         * @param {boolean} [isLocation] isLocation
         * @param {boolean} [isAdultContent] isAdultContent
         * @param {boolean} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postControllerUpdatePost(postId: string, title?: string, media?: Array<File>, tags?: Array<string>, category?: PostControllerUpdatePostCategoryEnum, collaborators?: Array<string>, description?: string, isPrivate?: boolean, isBlur?: boolean, tierId?: string, isScheduled?: boolean, price?: number, date?: string, time?: string, isLocation?: boolean, isAdultContent?: boolean, isDraft?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postControllerUpdatePost(postId, title, media, tags, category, collaborators, description, isPrivate, isBlur, tierId, isScheduled, price, date, time, isLocation, isAdultContent, isDraft, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postControllerUpdatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostsApiFp(configuration)
    return {
        /**
         *      This API is for adding comment on a post.     PostID is provided to this API as request parameter.     Comment text it takes in request body.     If no error or exception occur the this API will add comment in the post and return the newly created comment.
         * @summary 
         * @param {string} postId 
         * @param {CommentDataDto} commentDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerAddComment(postId: string, commentDataDto: CommentDataDto, options?: any): AxiosPromise<PostControllerUpdateComment200Response> {
            return localVarFp.postControllerAddComment(postId, commentDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for adding or removing the post into the or from the user favourites respectively.     If Post is Already in favouites of the user then it will remove it from the favourites.     If Post is not Already in favourites of the user then it will add it into the favourites.     it takes postId as the request parameter.     It will return success if no error or exception occurs.
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerAddOrRemoveToOrFromFavourites(postId: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerAddOrRemoveToOrFromFavourites(postId, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for creating a draft.     Consumes multi-part form data for creating Draft.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Returns the updated post if no error or exception occur.
         * @summary 
         * @param {string} [postId] Post id
         * @param {Array<File>} [file] images/videos
         * @param {Array<string>} [tags] tags
         * @param {string} [category] category
         * @param {string} [description] description
         * @param {PostControllerCreateDraftIsPrivateEnum} [isPrivate] isPrivate
         * @param {PostControllerCreateDraftIsBlurEnum} [isBlur] isBlur
         * @param {PostControllerCreateDraftIsFixedPriceEnum} [isFixedPrice] isFixedPrice
         * @param {number} [price] price
         * @param {string} [tierId] tierId
         * @param {PostControllerCreateDraftIsScheduledEnum} [isScheduled] isScheduled
         * @param {string} [date] date
         * @param {PostControllerCreateDraftIsLocationEnum} [isLocation] isLocation
         * @param {LocationDto} [location] location
         * @param {PostControllerCreateDraftIsAdultContentEnum} [isAdultContent] isAdultContent
         * @param {PostControllerCreateDraftIsDraftEnum} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerCreateDraft(postId?: string, file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreateDraftIsPrivateEnum, isBlur?: PostControllerCreateDraftIsBlurEnum, isFixedPrice?: PostControllerCreateDraftIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreateDraftIsScheduledEnum, date?: string, isLocation?: PostControllerCreateDraftIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreateDraftIsAdultContentEnum, isDraft?: PostControllerCreateDraftIsDraftEnum, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerCreateDraft(postId, file, tags, category, description, isPrivate, isBlur, isFixedPrice, price, tierId, isScheduled, date, isLocation, location, isAdultContent, isDraft, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for creating a new post.     Consumes multi-part form data for creating POST.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Either at least One Media File or Description is Required or Both     Returns the newly created post if no error or exception occur.     This API also can save the post as draft and whenever drafts post is edited and saved as new post the same API can do this work.
         * @summary 
         * @param {Array<File>} [file] images/videos
         * @param {Array<string>} [tags] tags
         * @param {string} [category] category
         * @param {string} [description] description
         * @param {PostControllerCreatePostIsPrivateEnum} [isPrivate] isPrivate
         * @param {PostControllerCreatePostIsBlurEnum} [isBlur] isBlur
         * @param {PostControllerCreatePostIsFixedPriceEnum} [isFixedPrice] isFixedPrice
         * @param {number} [price] price
         * @param {string} [tierId] tierId
         * @param {PostControllerCreatePostIsScheduledEnum} [isScheduled] isScheduled
         * @param {string} [date] date
         * @param {PostControllerCreatePostIsLocationEnum} [isLocation] isLocation
         * @param {LocationDto} [location] location
         * @param {PostControllerCreatePostIsAdultContentEnum} [isAdultContent] isAdultContent
         * @param {PostControllerCreatePostIsDraftEnum} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerCreatePost(file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreatePostIsPrivateEnum, isBlur?: PostControllerCreatePostIsBlurEnum, isFixedPrice?: PostControllerCreatePostIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreatePostIsScheduledEnum, date?: string, isLocation?: PostControllerCreatePostIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreatePostIsAdultContentEnum, isDraft?: PostControllerCreatePostIsDraftEnum, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerCreatePost(file, tags, category, description, isPrivate, isBlur, isFixedPrice, price, tierId, isScheduled, date, isLocation, location, isAdultContent, isDraft, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for deleting a comment from the existing post.     If no error or exception occur then it will delete the comment from the API.          Need to be updated later.
         * @summary 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerDeleteComment(commentId: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerDeleteComment(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for deleting a draft by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the draft all media files from the S3 storage
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerDeleteDraft(postId: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerDeleteDraft(postId, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for deleting a post by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the post all media files from the S3 storage
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerDeletePost(postId: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerDeletePost(postId, options).then((request) => request(axios, basePath));
        },
        /**
         *      This Api is for getting all the posts in the drafts of logged in User.     Returns the array of objects of drafts if no error or Exception Occurs
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetAllDrafts(options?: any): AxiosPromise<PostControllerGetAllDrafts200Response> {
            return localVarFp.postControllerGetAllDrafts(options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting all the Posts in the database that are recommended for the user who is logged In.     It returns an object containing the array of recommended/related posts according to the limit and offset in the optional query params     and total count of post that are recommended/related
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetAllRecommendedPostsForFeedSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetAllRecommendedPostsForFeed(limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetAllRecommendedPostsForFeedSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.postControllerGetAllRecommendedPostsForFeed(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting One Post by its Id provided as the request parameter.     If the posts with this Id exists and no error or exception occurs then it returns the details required for this post as a document.
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostById(postId: string, options?: any): AxiosPromise<PostControllerGetAllDrafts200Response> {
            return localVarFp.postControllerGetPostById(postId, options).then((request) => request(axios, basePath));
        },
        /**
         *        This API for get post data and comment data by postId And commentId.      
         * @summary 
         * @param {string} postId 
         * @param {string} commentId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostByIdAndCommentDataSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostByIdAndCommentData(postId: string, commentId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostByIdAndCommentDataSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.postControllerGetPostByIdAndCommentData(postId, commentId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} postId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostCommentsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostComments(postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostCommentsSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.postControllerGetPostComments(postId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This Api is for getting all the likes for a postId and postId provided as the request parameter.
         * @summary 
         * @param {string} postId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetPostLikesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetPostLikes(postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostLikesSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.postControllerGetPostLikes(postId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetUsersCollaboratorsPostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetUsersCollaboratorsPosts(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersCollaboratorsPostsSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postControllerGetUsersCollaboratorsPosts(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {PostControllerGetUsersFavouritePostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerGetUsersFavouritePosts(limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersFavouritePostsSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.postControllerGetUsersFavouritePosts(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for liking the post.     The postId it takes with request parameter and add the logged in userId in the likes List if not already liked the post     Also Create Activity of liking the post
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerLikePost(postId: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerLikePost(postId, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for unliking the post.     The postId it takes with request parameter and remove the logged in userId in the likes List if already liked the post.     
         * @summary 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerUnlikePost(postId: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.postControllerUnlikePost(postId, options).then((request) => request(axios, basePath));
        },
        /**
         *        This API updates the comments whose Id it takes as request body.       All Properties in request body are optional and provided properties will be updated in the database.      
         * @summary 
         * @param {string} commentId 
         * @param {UpdateCommentDto} updateCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerUpdateComment(commentId: string, updateCommentDto: UpdateCommentDto, options?: any): AxiosPromise<PostControllerUpdateComment200Response> {
            return localVarFp.postControllerUpdateComment(commentId, updateCommentDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API updates the post whose Id it takes as request body.     All Properties in request body are optional and provided properties will be updated in the database.     if new media is uploaded then it will delete previous media from S3 and upload new data on S3.     Returns the updated Post if no error or exception occurs.      Will Be Updated when Design will be finalized
         * @summary 
         * @param {string} postId 
         * @param {string} [title] title
         * @param {Array<File>} [media] images/videos
         * @param {Array<string>} [tags] tags
         * @param {PostControllerUpdatePostCategoryEnum} [category] category
         * @param {Array<string>} [collaborators] collaborators
         * @param {string} [description] description
         * @param {boolean} [isPrivate] isPrivate
         * @param {boolean} [isBlur] isBlur
         * @param {string} [tierId] tierId
         * @param {boolean} [isScheduled] isScheduled
         * @param {number} [price] price
         * @param {string} [date] date
         * @param {string} [time] time
         * @param {boolean} [isLocation] isLocation
         * @param {boolean} [isAdultContent] isAdultContent
         * @param {boolean} [isDraft] isDraft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postControllerUpdatePost(postId: string, title?: string, media?: Array<File>, tags?: Array<string>, category?: PostControllerUpdatePostCategoryEnum, collaborators?: Array<string>, description?: string, isPrivate?: boolean, isBlur?: boolean, tierId?: string, isScheduled?: boolean, price?: number, date?: string, time?: string, isLocation?: boolean, isAdultContent?: boolean, isDraft?: boolean, options?: any): AxiosPromise<PostResponseDto> {
            return localVarFp.postControllerUpdatePost(postId, title, media, tags, category, collaborators, description, isPrivate, isBlur, tierId, isScheduled, price, date, time, isLocation, isAdultContent, isDraft, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     *      This API is for adding comment on a post.     PostID is provided to this API as request parameter.     Comment text it takes in request body.     If no error or exception occur the this API will add comment in the post and return the newly created comment.
     * @summary 
     * @param {string} postId 
     * @param {CommentDataDto} commentDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerAddComment(postId: string, commentDataDto: CommentDataDto, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerAddComment(postId, commentDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for adding or removing the post into the or from the user favourites respectively.     If Post is Already in favouites of the user then it will remove it from the favourites.     If Post is not Already in favourites of the user then it will add it into the favourites.     it takes postId as the request parameter.     It will return success if no error or exception occurs.
     * @summary 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerAddOrRemoveToOrFromFavourites(postId: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerAddOrRemoveToOrFromFavourites(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for creating a draft.     Consumes multi-part form data for creating Draft.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Returns the updated post if no error or exception occur.
     * @summary 
     * @param {string} [postId] Post id
     * @param {Array<File>} [file] images/videos
     * @param {Array<string>} [tags] tags
     * @param {string} [category] category
     * @param {string} [description] description
     * @param {PostControllerCreateDraftIsPrivateEnum} [isPrivate] isPrivate
     * @param {PostControllerCreateDraftIsBlurEnum} [isBlur] isBlur
     * @param {PostControllerCreateDraftIsFixedPriceEnum} [isFixedPrice] isFixedPrice
     * @param {number} [price] price
     * @param {string} [tierId] tierId
     * @param {PostControllerCreateDraftIsScheduledEnum} [isScheduled] isScheduled
     * @param {string} [date] date
     * @param {PostControllerCreateDraftIsLocationEnum} [isLocation] isLocation
     * @param {LocationDto} [location] location
     * @param {PostControllerCreateDraftIsAdultContentEnum} [isAdultContent] isAdultContent
     * @param {PostControllerCreateDraftIsDraftEnum} [isDraft] isDraft
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerCreateDraft(postId?: string, file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreateDraftIsPrivateEnum, isBlur?: PostControllerCreateDraftIsBlurEnum, isFixedPrice?: PostControllerCreateDraftIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreateDraftIsScheduledEnum, date?: string, isLocation?: PostControllerCreateDraftIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreateDraftIsAdultContentEnum, isDraft?: PostControllerCreateDraftIsDraftEnum, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerCreateDraft(postId, file, tags, category, description, isPrivate, isBlur, isFixedPrice, price, tierId, isScheduled, date, isLocation, location, isAdultContent, isDraft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for creating a new post.     Consumes multi-part form data for creating POST.     Takes photos or videos as the media files from the form and upload them on S3 and saves their respective URLs as array of Strings in data base and returns this array with other post data.     Either at least One Media File or Description is Required or Both     Returns the newly created post if no error or exception occur.     This API also can save the post as draft and whenever drafts post is edited and saved as new post the same API can do this work.
     * @summary 
     * @param {Array<File>} [file] images/videos
     * @param {Array<string>} [tags] tags
     * @param {string} [category] category
     * @param {string} [description] description
     * @param {PostControllerCreatePostIsPrivateEnum} [isPrivate] isPrivate
     * @param {PostControllerCreatePostIsBlurEnum} [isBlur] isBlur
     * @param {PostControllerCreatePostIsFixedPriceEnum} [isFixedPrice] isFixedPrice
     * @param {number} [price] price
     * @param {string} [tierId] tierId
     * @param {PostControllerCreatePostIsScheduledEnum} [isScheduled] isScheduled
     * @param {string} [date] date
     * @param {PostControllerCreatePostIsLocationEnum} [isLocation] isLocation
     * @param {LocationDto} [location] location
     * @param {PostControllerCreatePostIsAdultContentEnum} [isAdultContent] isAdultContent
     * @param {PostControllerCreatePostIsDraftEnum} [isDraft] isDraft
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerCreatePost(file?: Array<File>, tags?: Array<string>, category?: string, description?: string, isPrivate?: PostControllerCreatePostIsPrivateEnum, isBlur?: PostControllerCreatePostIsBlurEnum, isFixedPrice?: PostControllerCreatePostIsFixedPriceEnum, price?: number, tierId?: string, isScheduled?: PostControllerCreatePostIsScheduledEnum, date?: string, isLocation?: PostControllerCreatePostIsLocationEnum, location?: LocationDto, isAdultContent?: PostControllerCreatePostIsAdultContentEnum, isDraft?: PostControllerCreatePostIsDraftEnum, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerCreatePost(file, tags, category, description, isPrivate, isBlur, isFixedPrice, price, tierId, isScheduled, date, isLocation, location, isAdultContent, isDraft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for deleting a comment from the existing post.     If no error or exception occur then it will delete the comment from the API.          Need to be updated later.
     * @summary 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerDeleteComment(commentId: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerDeleteComment(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for deleting a draft by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the draft all media files from the S3 storage
     * @summary 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerDeleteDraft(postId: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerDeleteDraft(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for deleting a post by its id provided in the request parameter.     The Post should belong to the logged in user.     If no error or exception occurs then return the success : true.     It also delete the post all media files from the S3 storage
     * @summary 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerDeletePost(postId: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerDeletePost(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This Api is for getting all the posts in the drafts of logged in User.     Returns the array of objects of drafts if no error or Exception Occurs
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetAllDrafts(options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetAllDrafts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting all the Posts in the database that are recommended for the user who is logged In.     It returns an object containing the array of recommended/related posts according to the limit and offset in the optional query params     and total count of post that are recommended/related
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {PostControllerGetAllRecommendedPostsForFeedSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetAllRecommendedPostsForFeed(limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetAllRecommendedPostsForFeedSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetAllRecommendedPostsForFeed(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting One Post by its Id provided as the request parameter.     If the posts with this Id exists and no error or exception occurs then it returns the details required for this post as a document.
     * @summary 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetPostById(postId: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetPostById(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        This API for get post data and comment data by postId And commentId.      
     * @summary 
     * @param {string} postId 
     * @param {string} commentId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {PostControllerGetPostByIdAndCommentDataSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetPostByIdAndCommentData(postId: string, commentId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostByIdAndCommentDataSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetPostByIdAndCommentData(postId, commentId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} postId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {PostControllerGetPostCommentsSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetPostComments(postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostCommentsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetPostComments(postId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This Api is for getting all the likes for a postId and postId provided as the request parameter.
     * @summary 
     * @param {string} postId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {PostControllerGetPostLikesSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetPostLikes(postId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetPostLikesSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetPostLikes(postId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {PostControllerGetUsersCollaboratorsPostsSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetUsersCollaboratorsPosts(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersCollaboratorsPostsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetUsersCollaboratorsPosts(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {PostControllerGetUsersFavouritePostsSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerGetUsersFavouritePosts(limit?: number, offset?: number, sortCol?: string, sortDir?: PostControllerGetUsersFavouritePostsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerGetUsersFavouritePosts(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for liking the post.     The postId it takes with request parameter and add the logged in userId in the likes List if not already liked the post     Also Create Activity of liking the post
     * @summary 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerLikePost(postId: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerLikePost(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for unliking the post.     The postId it takes with request parameter and remove the logged in userId in the likes List if already liked the post.     
     * @summary 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerUnlikePost(postId: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerUnlikePost(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        This API updates the comments whose Id it takes as request body.       All Properties in request body are optional and provided properties will be updated in the database.      
     * @summary 
     * @param {string} commentId 
     * @param {UpdateCommentDto} updateCommentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerUpdateComment(commentId: string, updateCommentDto: UpdateCommentDto, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerUpdateComment(commentId, updateCommentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API updates the post whose Id it takes as request body.     All Properties in request body are optional and provided properties will be updated in the database.     if new media is uploaded then it will delete previous media from S3 and upload new data on S3.     Returns the updated Post if no error or exception occurs.      Will Be Updated when Design will be finalized
     * @summary 
     * @param {string} postId 
     * @param {string} [title] title
     * @param {Array<File>} [media] images/videos
     * @param {Array<string>} [tags] tags
     * @param {PostControllerUpdatePostCategoryEnum} [category] category
     * @param {Array<string>} [collaborators] collaborators
     * @param {string} [description] description
     * @param {boolean} [isPrivate] isPrivate
     * @param {boolean} [isBlur] isBlur
     * @param {string} [tierId] tierId
     * @param {boolean} [isScheduled] isScheduled
     * @param {number} [price] price
     * @param {string} [date] date
     * @param {string} [time] time
     * @param {boolean} [isLocation] isLocation
     * @param {boolean} [isAdultContent] isAdultContent
     * @param {boolean} [isDraft] isDraft
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postControllerUpdatePost(postId: string, title?: string, media?: Array<File>, tags?: Array<string>, category?: PostControllerUpdatePostCategoryEnum, collaborators?: Array<string>, description?: string, isPrivate?: boolean, isBlur?: boolean, tierId?: string, isScheduled?: boolean, price?: number, date?: string, time?: string, isLocation?: boolean, isAdultContent?: boolean, isDraft?: boolean, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postControllerUpdatePost(postId, title, media, tags, category, collaborators, description, isPrivate, isBlur, tierId, isScheduled, price, date, time, isLocation, isAdultContent, isDraft, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PostControllerCreateDraftIsPrivateEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreateDraftIsPrivateEnum = typeof PostControllerCreateDraftIsPrivateEnum[keyof typeof PostControllerCreateDraftIsPrivateEnum];
/**
 * @export
 */
export const PostControllerCreateDraftIsBlurEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreateDraftIsBlurEnum = typeof PostControllerCreateDraftIsBlurEnum[keyof typeof PostControllerCreateDraftIsBlurEnum];
/**
 * @export
 */
export const PostControllerCreateDraftIsFixedPriceEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreateDraftIsFixedPriceEnum = typeof PostControllerCreateDraftIsFixedPriceEnum[keyof typeof PostControllerCreateDraftIsFixedPriceEnum];
/**
 * @export
 */
export const PostControllerCreateDraftIsScheduledEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreateDraftIsScheduledEnum = typeof PostControllerCreateDraftIsScheduledEnum[keyof typeof PostControllerCreateDraftIsScheduledEnum];
/**
 * @export
 */
export const PostControllerCreateDraftIsLocationEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreateDraftIsLocationEnum = typeof PostControllerCreateDraftIsLocationEnum[keyof typeof PostControllerCreateDraftIsLocationEnum];
/**
 * @export
 */
export const PostControllerCreateDraftIsAdultContentEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreateDraftIsAdultContentEnum = typeof PostControllerCreateDraftIsAdultContentEnum[keyof typeof PostControllerCreateDraftIsAdultContentEnum];
/**
 * @export
 */
export const PostControllerCreateDraftIsDraftEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreateDraftIsDraftEnum = typeof PostControllerCreateDraftIsDraftEnum[keyof typeof PostControllerCreateDraftIsDraftEnum];
/**
 * @export
 */
export const PostControllerCreatePostIsPrivateEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreatePostIsPrivateEnum = typeof PostControllerCreatePostIsPrivateEnum[keyof typeof PostControllerCreatePostIsPrivateEnum];
/**
 * @export
 */
export const PostControllerCreatePostIsBlurEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreatePostIsBlurEnum = typeof PostControllerCreatePostIsBlurEnum[keyof typeof PostControllerCreatePostIsBlurEnum];
/**
 * @export
 */
export const PostControllerCreatePostIsFixedPriceEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreatePostIsFixedPriceEnum = typeof PostControllerCreatePostIsFixedPriceEnum[keyof typeof PostControllerCreatePostIsFixedPriceEnum];
/**
 * @export
 */
export const PostControllerCreatePostIsScheduledEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreatePostIsScheduledEnum = typeof PostControllerCreatePostIsScheduledEnum[keyof typeof PostControllerCreatePostIsScheduledEnum];
/**
 * @export
 */
export const PostControllerCreatePostIsLocationEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreatePostIsLocationEnum = typeof PostControllerCreatePostIsLocationEnum[keyof typeof PostControllerCreatePostIsLocationEnum];
/**
 * @export
 */
export const PostControllerCreatePostIsAdultContentEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreatePostIsAdultContentEnum = typeof PostControllerCreatePostIsAdultContentEnum[keyof typeof PostControllerCreatePostIsAdultContentEnum];
/**
 * @export
 */
export const PostControllerCreatePostIsDraftEnum = {
    True: 'true',
    False: 'false'
} as const;
export type PostControllerCreatePostIsDraftEnum = typeof PostControllerCreatePostIsDraftEnum[keyof typeof PostControllerCreatePostIsDraftEnum];
/**
 * @export
 */
export const PostControllerGetAllRecommendedPostsForFeedSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type PostControllerGetAllRecommendedPostsForFeedSortDirEnum = typeof PostControllerGetAllRecommendedPostsForFeedSortDirEnum[keyof typeof PostControllerGetAllRecommendedPostsForFeedSortDirEnum];
/**
 * @export
 */
export const PostControllerGetPostByIdAndCommentDataSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type PostControllerGetPostByIdAndCommentDataSortDirEnum = typeof PostControllerGetPostByIdAndCommentDataSortDirEnum[keyof typeof PostControllerGetPostByIdAndCommentDataSortDirEnum];
/**
 * @export
 */
export const PostControllerGetPostCommentsSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type PostControllerGetPostCommentsSortDirEnum = typeof PostControllerGetPostCommentsSortDirEnum[keyof typeof PostControllerGetPostCommentsSortDirEnum];
/**
 * @export
 */
export const PostControllerGetPostLikesSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type PostControllerGetPostLikesSortDirEnum = typeof PostControllerGetPostLikesSortDirEnum[keyof typeof PostControllerGetPostLikesSortDirEnum];
/**
 * @export
 */
export const PostControllerGetUsersCollaboratorsPostsSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type PostControllerGetUsersCollaboratorsPostsSortDirEnum = typeof PostControllerGetUsersCollaboratorsPostsSortDirEnum[keyof typeof PostControllerGetUsersCollaboratorsPostsSortDirEnum];
/**
 * @export
 */
export const PostControllerGetUsersFavouritePostsSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type PostControllerGetUsersFavouritePostsSortDirEnum = typeof PostControllerGetUsersFavouritePostsSortDirEnum[keyof typeof PostControllerGetUsersFavouritePostsSortDirEnum];
/**
 * @export
 */
export const PostControllerUpdatePostCategoryEnum = {
    SolanaNfts: 'Solana NFTs',
    Art: 'Art',
    Collectibles: 'Collectibles',
    DomainNames: 'Domain Names',
    Music: 'Music',
    Photography: 'Photography',
    Sports: 'Sports',
    TradingCards: 'Trading Cards',
    Utility: 'Utility',
    VirtualWorlds: 'Virtual Worlds'
} as const;
export type PostControllerUpdatePostCategoryEnum = typeof PostControllerUpdatePostCategoryEnum[keyof typeof PostControllerUpdatePostCategoryEnum];


/**
 * ProblemApi - axios parameter creator
 * @export
 */
export const ProblemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      This API is for reporting a problem.     It takes reporter\'s and report\'s details and store them in the database.     Reporter can also send the screenshot/s of his/her problem.     It returns the saved reported problem if no error or exception occurs
         * @summary 
         * @param {string} email email
         * @param {string} inquiryRelatedTo inquiryRelatedTo
         * @param {string} issueDescription issueDescription
         * @param {Array<File>} [file] images/videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportProblemControllerReportProblem: async (email: string, inquiryRelatedTo: string, issueDescription: string, file?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('reportProblemControllerReportProblem', 'email', email)
            // verify required parameter 'inquiryRelatedTo' is not null or undefined
            assertParamExists('reportProblemControllerReportProblem', 'inquiryRelatedTo', inquiryRelatedTo)
            // verify required parameter 'issueDescription' is not null or undefined
            assertParamExists('reportProblemControllerReportProblem', 'issueDescription', issueDescription)
            const localVarPath = `/v1/report-problems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (inquiryRelatedTo !== undefined) { 
                localVarFormParams.append('inquiryRelatedTo', inquiryRelatedTo as any);
            }
    
            if (issueDescription !== undefined) { 
                localVarFormParams.append('issueDescription', issueDescription as any);
            }
                if (file) {
                file.forEach((element) => {
                    localVarFormParams.append('file', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProblemApi - functional programming interface
 * @export
 */
export const ProblemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProblemApiAxiosParamCreator(configuration)
    return {
        /**
         *      This API is for reporting a problem.     It takes reporter\'s and report\'s details and store them in the database.     Reporter can also send the screenshot/s of his/her problem.     It returns the saved reported problem if no error or exception occurs
         * @summary 
         * @param {string} email email
         * @param {string} inquiryRelatedTo inquiryRelatedTo
         * @param {string} issueDescription issueDescription
         * @param {Array<File>} [file] images/videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportProblemControllerReportProblem(email: string, inquiryRelatedTo: string, issueDescription: string, file?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportProblemControllerReportProblem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportProblemControllerReportProblem(email, inquiryRelatedTo, issueDescription, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemApi.reportProblemControllerReportProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProblemApi - factory interface
 * @export
 */
export const ProblemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProblemApiFp(configuration)
    return {
        /**
         *      This API is for reporting a problem.     It takes reporter\'s and report\'s details and store them in the database.     Reporter can also send the screenshot/s of his/her problem.     It returns the saved reported problem if no error or exception occurs
         * @summary 
         * @param {string} email email
         * @param {string} inquiryRelatedTo inquiryRelatedTo
         * @param {string} issueDescription issueDescription
         * @param {Array<File>} [file] images/videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportProblemControllerReportProblem(email: string, inquiryRelatedTo: string, issueDescription: string, file?: Array<File>, options?: any): AxiosPromise<ReportProblemControllerReportProblem200Response> {
            return localVarFp.reportProblemControllerReportProblem(email, inquiryRelatedTo, issueDescription, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProblemApi - object-oriented interface
 * @export
 * @class ProblemApi
 * @extends {BaseAPI}
 */
export class ProblemApi extends BaseAPI {
    /**
     *      This API is for reporting a problem.     It takes reporter\'s and report\'s details and store them in the database.     Reporter can also send the screenshot/s of his/her problem.     It returns the saved reported problem if no error or exception occurs
     * @summary 
     * @param {string} email email
     * @param {string} inquiryRelatedTo inquiryRelatedTo
     * @param {string} issueDescription issueDescription
     * @param {Array<File>} [file] images/videos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemApi
     */
    public reportProblemControllerReportProblem(email: string, inquiryRelatedTo: string, issueDescription: string, file?: Array<File>, options?: RawAxiosRequestConfig) {
        return ProblemApiFp(this.configuration).reportProblemControllerReportProblem(email, inquiryRelatedTo, issueDescription, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoryApi - axios parameter creator
 * @export
 */
export const StoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} media images/videos
         * @param {string} description description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyControllerCreate: async (media: File, description: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'media' is not null or undefined
            assertParamExists('storyControllerCreate', 'media', media)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('storyControllerCreate', 'description', description)
            const localVarPath = `/v1/story`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (media !== undefined) { 
                localVarFormParams.append('media', media as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteStoryDto} deleteStoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyControllerDeleteStory: async (deleteStoryDto: DeleteStoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteStoryDto' is not null or undefined
            assertParamExists('storyControllerDeleteStory', 'deleteStoryDto', deleteStoryDto)
            const localVarPath = `/v1/story`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteStoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {StoryControllerGetAllStoriesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyControllerGetAllStories: async (limit?: number, offset?: number, sortCol?: string, sortDir?: StoryControllerGetAllStoriesSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/story`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoryApi - functional programming interface
 * @export
 */
export const StoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} media images/videos
         * @param {string} description description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyControllerCreate(media: File, description: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseStoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyControllerCreate(media, description, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {DeleteStoryDto} deleteStoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyControllerDeleteStory(deleteStoryDto: DeleteStoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyControllerDeleteStory(deleteStoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyControllerDeleteStory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {StoryControllerGetAllStoriesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storyControllerGetAllStories(limit?: number, offset?: number, sortCol?: string, sortDir?: StoryControllerGetAllStoriesSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseStoryPaginationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storyControllerGetAllStories(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoryApi.storyControllerGetAllStories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StoryApi - factory interface
 * @export
 */
export const StoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoryApiFp(configuration)
    return {
        /**
         * 
         * @param {File} media images/videos
         * @param {string} description description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyControllerCreate(media: File, description: string, options?: any): AxiosPromise<ResponseStoryDto> {
            return localVarFp.storyControllerCreate(media, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteStoryDto} deleteStoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyControllerDeleteStory(deleteStoryDto: DeleteStoryDto, options?: any): AxiosPromise<void> {
            return localVarFp.storyControllerDeleteStory(deleteStoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {StoryControllerGetAllStoriesSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storyControllerGetAllStories(limit?: number, offset?: number, sortCol?: string, sortDir?: StoryControllerGetAllStoriesSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<ResponseStoryPaginationDto> {
            return localVarFp.storyControllerGetAllStories(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoryApi - object-oriented interface
 * @export
 * @class StoryApi
 * @extends {BaseAPI}
 */
export class StoryApi extends BaseAPI {
    /**
     * 
     * @param {File} media images/videos
     * @param {string} description description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyControllerCreate(media: File, description: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyControllerCreate(media, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteStoryDto} deleteStoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyControllerDeleteStory(deleteStoryDto: DeleteStoryDto, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyControllerDeleteStory(deleteStoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {StoryControllerGetAllStoriesSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoryApi
     */
    public storyControllerGetAllStories(limit?: number, offset?: number, sortCol?: string, sortDir?: StoryControllerGetAllStoriesSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return StoryApiFp(this.configuration).storyControllerGetAllStories(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StoryControllerGetAllStoriesSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type StoryControllerGetAllStoriesSortDirEnum = typeof StoryControllerGetAllStoriesSortDirEnum[keyof typeof StoryControllerGetAllStoriesSortDirEnum];


/**
 * StripsApi - axios parameter creator
 * @export
 */
export const StripsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PaymentIntentForPostDTO} paymentIntentForPostDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerCreateCheckoutSession: async (paymentIntentForPostDTO: PaymentIntentForPostDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentIntentForPostDTO' is not null or undefined
            assertParamExists('stripeControllerCreateCheckoutSession', 'paymentIntentForPostDTO', paymentIntentForPostDTO)
            const localVarPath = `/v1/stripe/paymentIntent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentForPostDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionDTO} subscriptionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerCreateSubscription: async (subscriptionDTO: SubscriptionDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionDTO' is not null or undefined
            assertParamExists('stripeControllerCreateSubscription', 'subscriptionDTO', subscriptionDTO)
            const localVarPath = `/v1/stripe/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripsApi - functional programming interface
 * @export
 */
export const StripsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PaymentIntentForPostDTO} paymentIntentForPostDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeControllerCreateCheckoutSession(paymentIntentForPostDTO: PaymentIntentForPostDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeControllerCreateCheckoutSession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeControllerCreateCheckoutSession(paymentIntentForPostDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripsApi.stripeControllerCreateCheckoutSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscriptionDTO} subscriptionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeControllerCreateSubscription(subscriptionDTO: SubscriptionDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeControllerCreateSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeControllerCreateSubscription(subscriptionDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripsApi.stripeControllerCreateSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripsApi - factory interface
 * @export
 */
export const StripsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripsApiFp(configuration)
    return {
        /**
         * 
         * @param {PaymentIntentForPostDTO} paymentIntentForPostDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerCreateCheckoutSession(paymentIntentForPostDTO: PaymentIntentForPostDTO, options?: any): AxiosPromise<StripeControllerCreateCheckoutSession200Response> {
            return localVarFp.stripeControllerCreateCheckoutSession(paymentIntentForPostDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionDTO} subscriptionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerCreateSubscription(subscriptionDTO: SubscriptionDTO, options?: any): AxiosPromise<StripeControllerCreateSubscription200Response> {
            return localVarFp.stripeControllerCreateSubscription(subscriptionDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripsApi - object-oriented interface
 * @export
 * @class StripsApi
 * @extends {BaseAPI}
 */
export class StripsApi extends BaseAPI {
    /**
     * 
     * @param {PaymentIntentForPostDTO} paymentIntentForPostDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripsApi
     */
    public stripeControllerCreateCheckoutSession(paymentIntentForPostDTO: PaymentIntentForPostDTO, options?: RawAxiosRequestConfig) {
        return StripsApiFp(this.configuration).stripeControllerCreateCheckoutSession(paymentIntentForPostDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionDTO} subscriptionDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripsApi
     */
    public stripeControllerCreateSubscription(subscriptionDTO: SubscriptionDTO, options?: RawAxiosRequestConfig) {
        return StripsApiFp(this.configuration).stripeControllerCreateSubscription(subscriptionDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsControllerGetTags: async (search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsControllerGetTags(search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsControllerGetTags(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsControllerGetTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsControllerGetTags(search?: string, options?: any): AxiosPromise<void> {
            return localVarFp.tagsControllerGetTags(search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsControllerGetTags(search?: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsControllerGetTags(search, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TiersApi - axios parameter creator
 * @export
 */
export const TiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      This API is to create new Tier after taking all the data in the body as multipart form data.     Saves Avatar on AWS S3 storage if uploaded.     Returns the newly created tier if no error or exception occurs.     
         * @summary 
         * @param {string} [name] name
         * @param {number} [price] price
         * @param {TiersControllerCreateTierCurrencyEnum} [currency] currency
         * @param {Array<string>} [benefits] benefits
         * @param {any} [avatar] avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerCreateTier: async (name?: string, price?: number, currency?: TiersControllerCreateTierCurrencyEnum, benefits?: Array<string>, avatar?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (currency !== undefined) { 
                localVarFormParams.append('currency', currency as any);
            }
                if (benefits) {
                localVarFormParams.append('benefits', benefits.join(COLLECTION_FORMATS.csv));
            }

    
            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', new Blob([JSON.stringify(avatar)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the tier whose Id is provided as request parameters.     Returns the document of Tier if no error or exception Occurs.     
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTierById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tiersControllerGetTierById', 'id', id)
            const localVarPath = `/v1/tiers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting all tiers created by the user that is logged In.     Return the array of existing tiers if no ERROR or EXCEPTION occurs.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTiers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting all the subscriber of the tier whose id is provided as the request parameter 
         * @summary 
         * @param {string} tierId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TiersControllerGetTiersSubscribersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTiersSubscribers: async (tierId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: TiersControllerGetTiersSubscribersSortDirEnum, filterCol?: string, filterVal?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('tiersControllerGetTiersSubscribers', 'tierId', tierId)
            const localVarPath = `/v1/tiers/tierSubscribers/{tierId}`
                .replace(`{${"tierId"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for searching the tier subscribe users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
         * @summary 
         * @param {string} tierId 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTiersSubscribersBySearchUsernameOrName: async (tierId: string, search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('tiersControllerGetTiersSubscribersBySearchUsernameOrName', 'tierId', tierId)
            // verify required parameter 'search' is not null or undefined
            assertParamExists('tiersControllerGetTiersSubscribersBySearchUsernameOrName', 'search', search)
            const localVarPath = `/v1/tiers/tierSubscribers/{tierId}/search`
                .replace(`{${"tierId"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        This API is for remove subscriber for a tier id.
         * @summary 
         * @param {RemoveSubscriberTierDto} removeSubscriberTierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerRemoveSubscriber: async (removeSubscriberTierDto: RemoveSubscriberTierDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeSubscriberTierDto' is not null or undefined
            assertParamExists('tiersControllerRemoveSubscriber', 'removeSubscriberTierDto', removeSubscriberTierDto)
            const localVarPath = `/v1/tiers/remove-subscriber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeSubscriberTierDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is for Suspend or Reactivate Subscription of login user
         * @summary 
         * @param {SubscribeTierDto} subscribeTierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerSuspendAndReactiveTier: async (subscribeTierDto: SubscribeTierDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeTierDto' is not null or undefined
            assertParamExists('tiersControllerSuspendAndReactiveTier', 'subscribeTierDto', subscribeTierDto)
            const localVarPath = `/v1/tiers/subscription/suspend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeTierDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This Api is for cancel tier subscription.
         * @summary 
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerUnSubscribeTier: async (tierId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('tiersControllerUnSubscribeTier', 'tierId', tierId)
            const localVarPath = `/v1/tiers/un-subscribe/{tierId}`
                .replace(`{${"tierId"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tierId 
         * @param {UpdateSubscriptionStatusAsOwnerDto} updateSubscriptionStatusAsOwnerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerUpdateSubscriptionStatus: async (tierId: string, updateSubscriptionStatusAsOwnerDto: UpdateSubscriptionStatusAsOwnerDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierId' is not null or undefined
            assertParamExists('tiersControllerUpdateSubscriptionStatus', 'tierId', tierId)
            // verify required parameter 'updateSubscriptionStatusAsOwnerDto' is not null or undefined
            assertParamExists('tiersControllerUpdateSubscriptionStatus', 'updateSubscriptionStatusAsOwnerDto', updateSubscriptionStatusAsOwnerDto)
            const localVarPath = `/v1/tiers/subscriptionStatusAsOwner/{tierId}`
                .replace(`{${"tierId"}}`, encodeURIComponent(String(tierId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubscriptionStatusAsOwnerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for updating the existing Tier by its Id comes with request body.     Returns the updated document if no error or Exception Occurs
         * @summary 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {number} [price] 
         * @param {Array<string>} [benefits] 
         * @param {any} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerUpdateTier: async (id?: string, name?: string, price?: number, benefits?: Array<string>, avatar?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (id !== undefined) { 
                localVarFormParams.append('_id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
                if (benefits) {
                localVarFormParams.append('benefits', benefits.join(COLLECTION_FORMATS.csv));
            }

    
            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', new Blob([JSON.stringify(avatar)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TiersApi - functional programming interface
 * @export
 */
export const TiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TiersApiAxiosParamCreator(configuration)
    return {
        /**
         *      This API is to create new Tier after taking all the data in the body as multipart form data.     Saves Avatar on AWS S3 storage if uploaded.     Returns the newly created tier if no error or exception occurs.     
         * @summary 
         * @param {string} [name] name
         * @param {number} [price] price
         * @param {TiersControllerCreateTierCurrencyEnum} [currency] currency
         * @param {Array<string>} [benefits] benefits
         * @param {any} [avatar] avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerCreateTier(name?: string, price?: number, currency?: TiersControllerCreateTierCurrencyEnum, benefits?: Array<string>, avatar?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TiersControllerUpdateTier200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerCreateTier(name, price, currency, benefits, avatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerCreateTier']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the tier whose Id is provided as request parameters.     Returns the document of Tier if no error or exception Occurs.     
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerGetTierById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TiersControllerUpdateTier200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerGetTierById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerGetTierById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting all tiers created by the user that is logged In.     Return the array of existing tiers if no ERROR or EXCEPTION occurs.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerGetTiers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TiersResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerGetTiers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerGetTiers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting all the subscriber of the tier whose id is provided as the request parameter 
         * @summary 
         * @param {string} tierId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TiersControllerGetTiersSubscribersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerGetTiersSubscribers(tierId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: TiersControllerGetTiersSubscribersSortDirEnum, filterCol?: string, filterVal?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerGetTiersSubscribers(tierId, limit, offset, sortCol, sortDir, filterCol, filterVal, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerGetTiersSubscribers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for searching the tier subscribe users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
         * @summary 
         * @param {string} tierId 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerGetTiersSubscribersBySearchUsernameOrName(tierId: string, search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerGetTiersSubscribersBySearchUsernameOrName(tierId, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerGetTiersSubscribersBySearchUsernameOrName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        This API is for remove subscriber for a tier id.
         * @summary 
         * @param {RemoveSubscriberTierDto} removeSubscriberTierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerRemoveSubscriber(removeSubscriberTierDto: RemoveSubscriberTierDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerRemoveSubscriber(removeSubscriberTierDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerRemoveSubscriber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is for Suspend or Reactivate Subscription of login user
         * @summary 
         * @param {SubscribeTierDto} subscribeTierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerSuspendAndReactiveTier(subscribeTierDto: SubscribeTierDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerSuspendAndReactiveTier(subscribeTierDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerSuspendAndReactiveTier']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This Api is for cancel tier subscription.
         * @summary 
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerUnSubscribeTier(tierId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerUnSubscribeTier(tierId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerUnSubscribeTier']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} tierId 
         * @param {UpdateSubscriptionStatusAsOwnerDto} updateSubscriptionStatusAsOwnerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerUpdateSubscriptionStatus(tierId: string, updateSubscriptionStatusAsOwnerDto: UpdateSubscriptionStatusAsOwnerDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerUpdateSubscriptionStatus(tierId, updateSubscriptionStatusAsOwnerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerUpdateSubscriptionStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for updating the existing Tier by its Id comes with request body.     Returns the updated document if no error or Exception Occurs
         * @summary 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {number} [price] 
         * @param {Array<string>} [benefits] 
         * @param {any} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tiersControllerUpdateTier(id?: string, name?: string, price?: number, benefits?: Array<string>, avatar?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TiersControllerUpdateTier200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tiersControllerUpdateTier(id, name, price, benefits, avatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TiersApi.tiersControllerUpdateTier']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TiersApi - factory interface
 * @export
 */
export const TiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TiersApiFp(configuration)
    return {
        /**
         *      This API is to create new Tier after taking all the data in the body as multipart form data.     Saves Avatar on AWS S3 storage if uploaded.     Returns the newly created tier if no error or exception occurs.     
         * @summary 
         * @param {string} [name] name
         * @param {number} [price] price
         * @param {TiersControllerCreateTierCurrencyEnum} [currency] currency
         * @param {Array<string>} [benefits] benefits
         * @param {any} [avatar] avatar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerCreateTier(name?: string, price?: number, currency?: TiersControllerCreateTierCurrencyEnum, benefits?: Array<string>, avatar?: any, options?: any): AxiosPromise<TiersControllerUpdateTier200Response> {
            return localVarFp.tiersControllerCreateTier(name, price, currency, benefits, avatar, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the tier whose Id is provided as request parameters.     Returns the document of Tier if no error or exception Occurs.     
         * @summary 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTierById(id: string, options?: any): AxiosPromise<TiersControllerUpdateTier200Response> {
            return localVarFp.tiersControllerGetTierById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting all tiers created by the user that is logged In.     Return the array of existing tiers if no ERROR or EXCEPTION occurs.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTiers(options?: any): AxiosPromise<Array<TiersResponseDto>> {
            return localVarFp.tiersControllerGetTiers(options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting all the subscriber of the tier whose id is provided as the request parameter 
         * @summary 
         * @param {string} tierId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TiersControllerGetTiersSubscribersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTiersSubscribers(tierId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: TiersControllerGetTiersSubscribersSortDirEnum, filterCol?: string, filterVal?: string, search?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.tiersControllerGetTiersSubscribers(tierId, limit, offset, sortCol, sortDir, filterCol, filterVal, search, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for searching the tier subscribe users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
         * @summary 
         * @param {string} tierId 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerGetTiersSubscribersBySearchUsernameOrName(tierId: string, search: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.tiersControllerGetTiersSubscribersBySearchUsernameOrName(tierId, search, options).then((request) => request(axios, basePath));
        },
        /**
         *        This API is for remove subscriber for a tier id.
         * @summary 
         * @param {RemoveSubscriberTierDto} removeSubscriberTierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerRemoveSubscriber(removeSubscriberTierDto: RemoveSubscriberTierDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.tiersControllerRemoveSubscriber(removeSubscriberTierDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is for Suspend or Reactivate Subscription of login user
         * @summary 
         * @param {SubscribeTierDto} subscribeTierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerSuspendAndReactiveTier(subscribeTierDto: SubscribeTierDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.tiersControllerSuspendAndReactiveTier(subscribeTierDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This Api is for cancel tier subscription.
         * @summary 
         * @param {string} tierId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerUnSubscribeTier(tierId: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.tiersControllerUnSubscribeTier(tierId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tierId 
         * @param {UpdateSubscriptionStatusAsOwnerDto} updateSubscriptionStatusAsOwnerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerUpdateSubscriptionStatus(tierId: string, updateSubscriptionStatusAsOwnerDto: UpdateSubscriptionStatusAsOwnerDto, options?: any): AxiosPromise<void> {
            return localVarFp.tiersControllerUpdateSubscriptionStatus(tierId, updateSubscriptionStatusAsOwnerDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for updating the existing Tier by its Id comes with request body.     Returns the updated document if no error or Exception Occurs
         * @summary 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {number} [price] 
         * @param {Array<string>} [benefits] 
         * @param {any} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tiersControllerUpdateTier(id?: string, name?: string, price?: number, benefits?: Array<string>, avatar?: any, options?: any): AxiosPromise<TiersControllerUpdateTier200Response> {
            return localVarFp.tiersControllerUpdateTier(id, name, price, benefits, avatar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TiersApi - object-oriented interface
 * @export
 * @class TiersApi
 * @extends {BaseAPI}
 */
export class TiersApi extends BaseAPI {
    /**
     *      This API is to create new Tier after taking all the data in the body as multipart form data.     Saves Avatar on AWS S3 storage if uploaded.     Returns the newly created tier if no error or exception occurs.     
     * @summary 
     * @param {string} [name] name
     * @param {number} [price] price
     * @param {TiersControllerCreateTierCurrencyEnum} [currency] currency
     * @param {Array<string>} [benefits] benefits
     * @param {any} [avatar] avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerCreateTier(name?: string, price?: number, currency?: TiersControllerCreateTierCurrencyEnum, benefits?: Array<string>, avatar?: any, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerCreateTier(name, price, currency, benefits, avatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the tier whose Id is provided as request parameters.     Returns the document of Tier if no error or exception Occurs.     
     * @summary 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerGetTierById(id: string, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerGetTierById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting all tiers created by the user that is logged In.     Return the array of existing tiers if no ERROR or EXCEPTION occurs.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerGetTiers(options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerGetTiers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting all the subscriber of the tier whose id is provided as the request parameter 
     * @summary 
     * @param {string} tierId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {TiersControllerGetTiersSubscribersSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerGetTiersSubscribers(tierId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: TiersControllerGetTiersSubscribersSortDirEnum, filterCol?: string, filterVal?: string, search?: string, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerGetTiersSubscribers(tierId, limit, offset, sortCol, sortDir, filterCol, filterVal, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for searching the tier subscribe users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
     * @summary 
     * @param {string} tierId 
     * @param {string} search 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerGetTiersSubscribersBySearchUsernameOrName(tierId: string, search: string, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerGetTiersSubscribersBySearchUsernameOrName(tierId, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        This API is for remove subscriber for a tier id.
     * @summary 
     * @param {RemoveSubscriberTierDto} removeSubscriberTierDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerRemoveSubscriber(removeSubscriberTierDto: RemoveSubscriberTierDto, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerRemoveSubscriber(removeSubscriberTierDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is for Suspend or Reactivate Subscription of login user
     * @summary 
     * @param {SubscribeTierDto} subscribeTierDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerSuspendAndReactiveTier(subscribeTierDto: SubscribeTierDto, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerSuspendAndReactiveTier(subscribeTierDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This Api is for cancel tier subscription.
     * @summary 
     * @param {string} tierId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerUnSubscribeTier(tierId: string, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerUnSubscribeTier(tierId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tierId 
     * @param {UpdateSubscriptionStatusAsOwnerDto} updateSubscriptionStatusAsOwnerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerUpdateSubscriptionStatus(tierId: string, updateSubscriptionStatusAsOwnerDto: UpdateSubscriptionStatusAsOwnerDto, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerUpdateSubscriptionStatus(tierId, updateSubscriptionStatusAsOwnerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for updating the existing Tier by its Id comes with request body.     Returns the updated document if no error or Exception Occurs
     * @summary 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {number} [price] 
     * @param {Array<string>} [benefits] 
     * @param {any} [avatar] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TiersApi
     */
    public tiersControllerUpdateTier(id?: string, name?: string, price?: number, benefits?: Array<string>, avatar?: any, options?: RawAxiosRequestConfig) {
        return TiersApiFp(this.configuration).tiersControllerUpdateTier(id, name, price, benefits, avatar, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TiersControllerCreateTierCurrencyEnum = {
    Usd: 'USD'
} as const;
export type TiersControllerCreateTierCurrencyEnum = typeof TiersControllerCreateTierCurrencyEnum[keyof typeof TiersControllerCreateTierCurrencyEnum];
/**
 * @export
 */
export const TiersControllerGetTiersSubscribersSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type TiersControllerGetTiersSubscribersSortDirEnum = typeof TiersControllerGetTiersSubscribersSortDirEnum[keyof typeof TiersControllerGetTiersSubscribersSortDirEnum];


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is for getting the users payment history
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TransactionControllerGetUserPaymentHistorySortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionControllerGetUserPaymentHistory: async (limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserPaymentHistorySortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transactions/payment/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is for getting the users transaction history
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TransactionControllerGetUserTransactionSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionControllerGetUserTransaction: async (limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserTransactionSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transactions/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is for getting the users payment history
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TransactionControllerGetUserPaymentHistorySortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionControllerGetUserPaymentHistory(limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserPaymentHistorySortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionControllerGetUserPaymentHistory(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.transactionControllerGetUserPaymentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is for getting the users transaction history
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TransactionControllerGetUserTransactionSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionControllerGetUserTransaction(limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserTransactionSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionControllerGetUserTransaction(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.transactionControllerGetUserTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * This API is for getting the users payment history
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TransactionControllerGetUserPaymentHistorySortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionControllerGetUserPaymentHistory(limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserPaymentHistorySortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.transactionControllerGetUserPaymentHistory(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is for getting the users transaction history
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {TransactionControllerGetUserTransactionSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionControllerGetUserTransaction(limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserTransactionSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.transactionControllerGetUserTransaction(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * This API is for getting the users payment history
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {TransactionControllerGetUserPaymentHistorySortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionControllerGetUserPaymentHistory(limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserPaymentHistorySortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionControllerGetUserPaymentHistory(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is for getting the users transaction history
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {TransactionControllerGetUserTransactionSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public transactionControllerGetUserTransaction(limit?: number, offset?: number, sortCol?: string, sortDir?: TransactionControllerGetUserTransactionSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).transactionControllerGetUserTransaction(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TransactionControllerGetUserPaymentHistorySortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type TransactionControllerGetUserPaymentHistorySortDirEnum = typeof TransactionControllerGetUserPaymentHistorySortDirEnum[keyof typeof TransactionControllerGetUserPaymentHistorySortDirEnum];
/**
 * @export
 */
export const TransactionControllerGetUserTransactionSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type TransactionControllerGetUserTransactionSortDirEnum = typeof TransactionControllerGetUserTransactionSortDirEnum[keyof typeof TransactionControllerGetUserTransactionSortDirEnum];


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *      This API is to add a user id provided in the body of request in the followings of logged in user if not already and     add the logged In user id in the followers list of user id provided in the body of request if not already   
         * @summary 
         * @param {FollowProfileDto} followProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddFollower: async (followProfileDto: FollowProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followProfileDto' is not null or undefined
            assertParamExists('userControllerAddFollower', 'followProfileDto', followProfileDto)
            const localVarPath = `/v1/users/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is for change password of login user
         * @summary 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerChangePassword: async (changePasswordDto: ChangePasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('userControllerChangePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/v1/users/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is for clear all recent search history of login user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerClearAllRecentSearch: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/recentHistory/clearAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is for delete a recent search history data of login user
         * @summary 
         * @param {RecentSearchTextDto} recentSearchTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerClearRecentSearchText: async (recentSearchTextDto: RecentSearchTextDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recentSearchTextDto' is not null or undefined
            assertParamExists('userControllerClearRecentSearchText', 'recentSearchTextDto', recentSearchTextDto)
            const localVarPath = `/v1/users/recentHistory/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recentSearchTextDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for delete a user.
         * @summary 
         * @param {DeleteUserDTO} deleteUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteUser: async (deleteUserDTO: DeleteUserDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteUserDTO' is not null or undefined
            assertParamExists('userControllerDeleteUser', 'deleteUserDTO', deleteUserDTO)
            const localVarPath = `/v1/users/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the user Details whose username is provided as the parameter.     
         * @summary 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userControllerFindByUsername', 'username', username)
            const localVarPath = `/v1/users/profile/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the users profile.     It will return all the details of the user who is logged in.     It takes sub of logged in user from its token and then search with sub of user in the database. 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is for getting all the users who request for follow of login user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFollowRequests: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/follow/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the users balances.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetBalances: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/{userId}/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for searching the users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
         * @summary 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetCollaborators: async (search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('userControllerGetCollaborators', 'search', search)
            const localVarPath = `/v1/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for Getting all the followers of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of followers according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetFollowersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetFollowers: async (userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowersSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerGetFollowers', 'userId', userId)
            const localVarPath = `/v1/users/followers/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for Getting all the following of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of following according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetFollowingSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetFollowing: async (userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowingSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerGetFollowing', 'userId', userId)
            const localVarPath = `/v1/users/following/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyFollowersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyFollowers: async (limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowersSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyFollowingSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyFollowing: async (limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowingSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for Getting all the posts of logged in User.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyPostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyPosts: async (limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/myposts/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for Getting all the posts of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyPostsByUserIdSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyPostsByUserId: async (userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsByUserIdSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerGetMyPostsByUserId', 'userId', userId)
            const localVarPath = `/v1/users/myposts/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMySubscriptionsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMySubscriptions: async (limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMySubscriptionsSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/mySubscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        This API is for getting my tiers list of logged in User.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyTiers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/mytiers/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the users settings for notifications.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetNotificationSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/settings/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the users settings for privacy and security.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetPrivacySettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/settings/privacy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *         This API is for getting tiers list of user id which is provides as request parameter.
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetProfileTiers: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerGetProfileTiers', 'userId', userId)
            const localVarPath = `/v1/users/mytiers/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to get the list of recommended user on base of several similarities.     
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetRecommendedProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/recommended/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetTrendingUsersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetTrendingUsers: async (limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetTrendingUsersSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/trendings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for getting the user Details whose id is provided as the parameter.     
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerGetUser', 'userId', userId)
            const localVarPath = `/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users with optionally paginations, sorting, and filtering.
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetUsersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUsers: async (limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetUsersSortDirEnum, filterCol?: string, filterVal?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortCol !== undefined) {
                localVarQueryParameter['sortCol'] = sortCol;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (filterCol !== undefined) {
                localVarQueryParameter['filterCol'] = filterCol;
            }

            if (filterVal !== undefined) {
                localVarQueryParameter['filterVal'] = filterVal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *       This API is to update a user\'s lang settings.
         * @summary 
         * @param {string} userId 
         * @param {UserLangSettingDto} userLangSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLagSettings: async (userId: string, userLangSettingDto: UserLangSettingDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerLagSettings', 'userId', userId)
            // verify required parameter 'userLangSettingDto' is not null or undefined
            assertParamExists('userControllerLagSettings', 'userLangSettingDto', userLangSettingDto)
            const localVarPath = `/v1/users/settings/lang/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLangSettingDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to update a user\'s profile setup step 1 details.     The name, username parameters are mandatory while description is optional.
         * @summary 
         * @param {ProfileSetupOneDto} profileSetupOneDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerProfileSetup: async (profileSetupOneDto: ProfileSetupOneDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileSetupOneDto' is not null or undefined
            assertParamExists('userControllerProfileSetup', 'profileSetupOneDto', profileSetupOneDto)
            const localVarPath = `/v1/users/profileSetup/one`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileSetupOneDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to update a user\'s profile step 3 details.
         * @summary 
         * @param {UserControllerProfileSetupAboutRequest} userControllerProfileSetupAboutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerProfileSetupAbout: async (userControllerProfileSetupAboutRequest: UserControllerProfileSetupAboutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userControllerProfileSetupAboutRequest' is not null or undefined
            assertParamExists('userControllerProfileSetupAbout', 'userControllerProfileSetupAboutRequest', userControllerProfileSetupAboutRequest)
            const localVarPath = `/v1/users/profileSetup/three`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userControllerProfileSetupAboutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to update a user\'s profile step 2 details.     It Takes multipart form data input and updates the existing logged in user avatar.     Returns the updated object after successful update.
         * @summary 
         * @param {boolean} [skip] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerProfileSetupAvatar: async (skip?: boolean, file?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/profileSetup/two`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (skip !== undefined) { 
                localVarFormParams.append('skip', String(skip) as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for remove a follower from login profile.   
         * @summary 
         * @param {UnFollowProfileDto} unFollowProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveFollower: async (unFollowProfileDto: UnFollowProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'unFollowProfileDto' is not null or undefined
            assertParamExists('userControllerRemoveFollower', 'unFollowProfileDto', unFollowProfileDto)
            const localVarPath = `/v1/users/follower/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unFollowProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for unfollow a profile.   
         * @summary 
         * @param {UnFollowProfileDto} unFollowProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUnFollow: async (unFollowProfileDto: UnFollowProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'unFollowProfileDto' is not null or undefined
            assertParamExists('userControllerUnFollow', 'unFollowProfileDto', unFollowProfileDto)
            const localVarPath = `/v1/users/unfollow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unFollowProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is for update status of follow request.   
         * @summary 
         * @param {UpdateFollowStatusDto} updateFollowStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUnFollower: async (updateFollowStatusDto: UpdateFollowStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateFollowStatusDto' is not null or undefined
            assertParamExists('userControllerUnFollower', 'updateFollowStatusDto', updateFollowStatusDto)
            const localVarPath = `/v1/users/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFollowStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to update a user\'s avatar.
         * @summary 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateAvatar: async (file?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateRecentHistory: async (search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('userControllerUpdateRecentHistory', 'search', search)
            const localVarPath = `/v1/users/recentHistory/{search}`
                .replace(`{${"search"}}`, encodeURIComponent(String(search)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to update a user\'s settings.
         * @summary 
         * @param {string} userId 
         * @param {UserSettingDto} userSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateSettings: async (userId: string, userSettingDto: UserSettingDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerUpdateSettings', 'userId', userId)
            // verify required parameter 'userSettingDto' is not null or undefined
            assertParamExists('userControllerUpdateSettings', 'userSettingDto', userSettingDto)
            const localVarPath = `/v1/users/settings/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSettingDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to update a user\'s status.
         * @summary 
         * @param {UpdateStatusDto} updateStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus: async (updateStatusDto: UpdateStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateStatusDto' is not null or undefined
            assertParamExists('userControllerUpdateStatus', 'updateStatusDto', updateStatusDto)
            const localVarPath = `/v1/users/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to update a user details by userId param In user.     It Takes multipart form data input and updated the existing logged in user record.     returns the updated Object after successful update of records if no ERROR or EXCEPTION occurs.
         * @summary 
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {string} [description] 
         * @param {Array<string>} [tags] 
         * @param {UserControllerUpdateUserByUserIdRequestSocials} [socials] 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateUserByUserId: async (userId: string, name?: string, username?: string, description?: string, tags?: Array<string>, socials?: UserControllerUpdateUserByUserIdRequestSocials, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerUpdateUserByUserId', 'userId', userId)
            const localVarPath = `/v1/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
                if (tags) {
                localVarFormParams.append('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
            if (socials !== undefined) { 
                localVarFormParams.append('socials', new Blob([JSON.stringify(socials)], { type: "application/json", }));
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      This API is to check whether the username provided in the request parameters already exists or not.     If username already then return true otherwise return false
         * @summary 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUserNameExists: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userControllerUserNameExists', 'username', username)
            const localVarPath = `/v1/users/usernameExists/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         *      This API is to add a user id provided in the body of request in the followings of logged in user if not already and     add the logged In user id in the followers list of user id provided in the body of request if not already   
         * @summary 
         * @param {FollowProfileDto} followProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerAddFollower(followProfileDto: FollowProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerAddFollower(followProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerAddFollower']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is for change password of login user
         * @summary 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerChangePassword(changePasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is for clear all recent search history of login user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerClearAllRecentSearch(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerClearAllRecentSearch(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerClearAllRecentSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is for delete a recent search history data of login user
         * @summary 
         * @param {RecentSearchTextDto} recentSearchTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerClearRecentSearchText(recentSearchTextDto: RecentSearchTextDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerClearRecentSearchText(recentSearchTextDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerClearRecentSearchText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for delete a user.
         * @summary 
         * @param {DeleteUserDTO} deleteUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerDeleteUser(deleteUserDTO: DeleteUserDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerDeleteUser(deleteUserDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the user Details whose username is provided as the parameter.     
         * @summary 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the users profile.     It will return all the details of the user who is logged in.     It takes sub of logged in user from its token and then search with sub of user in the database. 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFindOne(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFindOne(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is for getting all the users who request for follow of login user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFollowRequests(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFollowRequests200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFollowRequests(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerFollowRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the users balances.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetBalances(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetBalances(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for searching the users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
         * @summary 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetCollaborators(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CollaboratorsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetCollaborators(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetCollaborators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for Getting all the followers of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of followers according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetFollowersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetFollowers(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetFollowers(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetFollowers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for Getting all the following of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of following according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetFollowingSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetFollowing(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowingSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetFollowing(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyFollowersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMyFollowers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMyFollowers(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMyFollowers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyFollowingSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMyFollowing(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowingSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMyFollowing(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMyFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for Getting all the posts of logged in User.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyPostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMyPosts(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMyPosts(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMyPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for Getting all the posts of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyPostsByUserIdSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMyPostsByUserId(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsByUserIdSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMyPostsByUserId(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMyPostsByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMySubscriptionsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMySubscriptions(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMySubscriptionsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMySubscriptions(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMySubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *        This API is for getting my tiers list of logged in User.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetMyTiers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetMyTiers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetMyTiers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetMyTiers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the users settings for notifications.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetNotificationSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetNotificationSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetNotificationSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetNotificationSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the users settings for privacy and security.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetPrivacySettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetPrivacySettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetPrivacySettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetPrivacySettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *         This API is for getting tiers list of user id which is provides as request parameter.
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetProfileTiers(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetMyTiers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetProfileTiers(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetProfileTiers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to get the list of recommended user on base of several similarities.     
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetRecommendedProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetRecommendedProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetRecommendedProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetTrendingUsersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetTrendingUsers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetTrendingUsersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetTrendingUsers(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetTrendingUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for getting the user Details whose id is provided as the parameter.     
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve users with optionally paginations, sorting, and filtering.
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetUsersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetUsers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetUsersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerGetTrendingUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetUsers(limit, offset, sortCol, sortDir, filterCol, filterVal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *       This API is to update a user\'s lang settings.
         * @summary 
         * @param {string} userId 
         * @param {UserLangSettingDto} userLangSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerLagSettings(userId: string, userLangSettingDto: UserLangSettingDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerLagSettings(userId, userLangSettingDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerLagSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to update a user\'s profile setup step 1 details.     The name, username parameters are mandatory while description is optional.
         * @summary 
         * @param {ProfileSetupOneDto} profileSetupOneDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerProfileSetup(profileSetupOneDto: ProfileSetupOneDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerProfileSetup(profileSetupOneDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerProfileSetup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to update a user\'s profile step 3 details.
         * @summary 
         * @param {UserControllerProfileSetupAboutRequest} userControllerProfileSetupAboutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerProfileSetupAbout(userControllerProfileSetupAboutRequest: UserControllerProfileSetupAboutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerProfileSetupAbout(userControllerProfileSetupAboutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerProfileSetupAbout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to update a user\'s profile step 2 details.     It Takes multipart form data input and updates the existing logged in user avatar.     Returns the updated object after successful update.
         * @summary 
         * @param {boolean} [skip] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerProfileSetupAvatar(skip?: boolean, file?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerProfileSetupAvatar(skip, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerProfileSetupAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for remove a follower from login profile.   
         * @summary 
         * @param {UnFollowProfileDto} unFollowProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemoveFollower(unFollowProfileDto: UnFollowProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemoveFollower(unFollowProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerRemoveFollower']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for unfollow a profile.   
         * @summary 
         * @param {UnFollowProfileDto} unFollowProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUnFollow(unFollowProfileDto: UnFollowProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnFollow(unFollowProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUnFollow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is for update status of follow request.   
         * @summary 
         * @param {UpdateFollowStatusDto} updateFollowStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUnFollower(updateFollowStatusDto: UpdateFollowStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnFollower(updateFollowStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUnFollower']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to update a user\'s avatar.
         * @summary 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateAvatar(file?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateAvatar(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateRecentHistory(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateRecentHistory(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateRecentHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to update a user\'s settings.
         * @summary 
         * @param {string} userId 
         * @param {UserSettingDto} userSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateSettings(userId: string, userSettingDto: UserSettingDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUpdateSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateSettings(userId, userSettingDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to update a user\'s status.
         * @summary 
         * @param {UpdateStatusDto} updateStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateStatus(updateStatusDto: UpdateStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateStatus(updateStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to update a user details by userId param In user.     It Takes multipart form data input and updated the existing logged in user record.     returns the updated Object after successful update of records if no ERROR or EXCEPTION occurs.
         * @summary 
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {string} [description] 
         * @param {Array<string>} [tags] 
         * @param {UserControllerUpdateUserByUserIdRequestSocials} [socials] 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateUserByUserId(userId: string, name?: string, username?: string, description?: string, tags?: Array<string>, socials?: UserControllerUpdateUserByUserIdRequestSocials, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerFindOne200ResponsePayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateUserByUserId(userId, name, username, description, tags, socials, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateUserByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      This API is to check whether the username provided in the request parameters already exists or not.     If username already then return true otherwise return false
         * @summary 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUserNameExists(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserControllerUserNameExists200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUserNameExists(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUserNameExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         *      This API is to add a user id provided in the body of request in the followings of logged in user if not already and     add the logged In user id in the followers list of user id provided in the body of request if not already   
         * @summary 
         * @param {FollowProfileDto} followProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddFollower(followProfileDto: FollowProfileDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerAddFollower(followProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is for change password of login user
         * @summary 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerChangePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is for clear all recent search history of login user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerClearAllRecentSearch(options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerClearAllRecentSearch(options).then((request) => request(axios, basePath));
        },
        /**
         * This API is for delete a recent search history data of login user
         * @summary 
         * @param {RecentSearchTextDto} recentSearchTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerClearRecentSearchText(recentSearchTextDto: RecentSearchTextDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerClearRecentSearchText(recentSearchTextDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for delete a user.
         * @summary 
         * @param {DeleteUserDTO} deleteUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteUser(deleteUserDTO: DeleteUserDTO, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerDeleteUser(deleteUserDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the user Details whose username is provided as the parameter.     
         * @summary 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindByUsername(username: string, options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerFindByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the users profile.     It will return all the details of the user who is logged in.     It takes sub of logged in user from its token and then search with sub of user in the database. 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindOne(options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerFindOne(options).then((request) => request(axios, basePath));
        },
        /**
         * This API is for getting all the users who request for follow of login user
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFollowRequests(options?: any): AxiosPromise<UserControllerFollowRequests200Response> {
            return localVarFp.userControllerFollowRequests(options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the users balances.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetBalances(options?: any): AxiosPromise<void> {
            return localVarFp.userControllerGetBalances(options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for searching the users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
         * @summary 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetCollaborators(search: string, options?: any): AxiosPromise<Array<CollaboratorsDto>> {
            return localVarFp.userControllerGetCollaborators(search, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for Getting all the followers of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of followers according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetFollowersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetFollowers(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowersSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetFollowers(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for Getting all the following of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of following according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetFollowingSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetFollowing(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowingSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetFollowing(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyFollowersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyFollowers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowersSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetMyFollowers(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyFollowingSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyFollowing(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowingSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetMyFollowing(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for Getting all the posts of logged in User.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyPostsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyPosts(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetMyPosts(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for Getting all the posts of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
         * @summary 
         * @param {string} userId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMyPostsByUserIdSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyPostsByUserId(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsByUserIdSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetMyPostsByUserId(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetMySubscriptionsSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMySubscriptions(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMySubscriptionsSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetMySubscriptions(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *        This API is for getting my tiers list of logged in User.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetMyTiers(options?: any): AxiosPromise<UserControllerGetMyTiers200Response> {
            return localVarFp.userControllerGetMyTiers(options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the users settings for notifications.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetNotificationSettings(options?: any): AxiosPromise<UserControllerGetNotificationSettings200Response> {
            return localVarFp.userControllerGetNotificationSettings(options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the users settings for privacy and security.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetPrivacySettings(options?: any): AxiosPromise<UserControllerGetPrivacySettings200Response> {
            return localVarFp.userControllerGetPrivacySettings(options).then((request) => request(axios, basePath));
        },
        /**
         *         This API is for getting tiers list of user id which is provides as request parameter.
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetProfileTiers(userId: string, options?: any): AxiosPromise<UserControllerGetMyTiers200Response> {
            return localVarFp.userControllerGetProfileTiers(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to get the list of recommended user on base of several similarities.     
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetRecommendedProfiles(options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerGetRecommendedProfiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetTrendingUsersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetTrendingUsers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetTrendingUsersSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetTrendingUsers(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for getting the user Details whose id is provided as the parameter.     
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser(userId: string, options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerGetUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users with optionally paginations, sorting, and filtering.
         * @summary 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [sortCol] 
         * @param {UserControllerGetUsersSortDirEnum} [sortDir] 
         * @param {string} [filterCol] 
         * @param {string} [filterVal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUsers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetUsersSortDirEnum, filterCol?: string, filterVal?: string, options?: any): AxiosPromise<UserControllerGetTrendingUsers200Response> {
            return localVarFp.userControllerGetUsers(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(axios, basePath));
        },
        /**
         *       This API is to update a user\'s lang settings.
         * @summary 
         * @param {string} userId 
         * @param {UserLangSettingDto} userLangSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLagSettings(userId: string, userLangSettingDto: UserLangSettingDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerLagSettings(userId, userLangSettingDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to update a user\'s profile setup step 1 details.     The name, username parameters are mandatory while description is optional.
         * @summary 
         * @param {ProfileSetupOneDto} profileSetupOneDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerProfileSetup(profileSetupOneDto: ProfileSetupOneDto, options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerProfileSetup(profileSetupOneDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to update a user\'s profile step 3 details.
         * @summary 
         * @param {UserControllerProfileSetupAboutRequest} userControllerProfileSetupAboutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerProfileSetupAbout(userControllerProfileSetupAboutRequest: UserControllerProfileSetupAboutRequest, options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerProfileSetupAbout(userControllerProfileSetupAboutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to update a user\'s profile step 2 details.     It Takes multipart form data input and updates the existing logged in user avatar.     Returns the updated object after successful update.
         * @summary 
         * @param {boolean} [skip] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerProfileSetupAvatar(skip?: boolean, file?: any, options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerProfileSetupAvatar(skip, file, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for remove a follower from login profile.   
         * @summary 
         * @param {UnFollowProfileDto} unFollowProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveFollower(unFollowProfileDto: UnFollowProfileDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerRemoveFollower(unFollowProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for unfollow a profile.   
         * @summary 
         * @param {UnFollowProfileDto} unFollowProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUnFollow(unFollowProfileDto: UnFollowProfileDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerUnFollow(unFollowProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is for update status of follow request.   
         * @summary 
         * @param {UpdateFollowStatusDto} updateFollowStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUnFollower(updateFollowStatusDto: UpdateFollowStatusDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerUnFollower(updateFollowStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to update a user\'s avatar.
         * @summary 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateAvatar(file?: any, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerUpdateAvatar(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateRecentHistory(search: string, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.userControllerUpdateRecentHistory(search, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to update a user\'s settings.
         * @summary 
         * @param {string} userId 
         * @param {UserSettingDto} userSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateSettings(userId: string, userSettingDto: UserSettingDto, options?: any): AxiosPromise<UserControllerUpdateSettings200Response> {
            return localVarFp.userControllerUpdateSettings(userId, userSettingDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to update a user\'s status.
         * @summary 
         * @param {UpdateStatusDto} updateStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateStatus(updateStatusDto: UpdateStatusDto, options?: any): AxiosPromise<UserControllerFindOne200Response> {
            return localVarFp.userControllerUpdateStatus(updateStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to update a user details by userId param In user.     It Takes multipart form data input and updated the existing logged in user record.     returns the updated Object after successful update of records if no ERROR or EXCEPTION occurs.
         * @summary 
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {string} [description] 
         * @param {Array<string>} [tags] 
         * @param {UserControllerUpdateUserByUserIdRequestSocials} [socials] 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateUserByUserId(userId: string, name?: string, username?: string, description?: string, tags?: Array<string>, socials?: UserControllerUpdateUserByUserIdRequestSocials, category?: string, options?: any): AxiosPromise<UserControllerFindOne200ResponsePayload> {
            return localVarFp.userControllerUpdateUserByUserId(userId, name, username, description, tags, socials, category, options).then((request) => request(axios, basePath));
        },
        /**
         *      This API is to check whether the username provided in the request parameters already exists or not.     If username already then return true otherwise return false
         * @summary 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUserNameExists(username: string, options?: any): AxiosPromise<UserControllerUserNameExists200Response> {
            return localVarFp.userControllerUserNameExists(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *      This API is to add a user id provided in the body of request in the followings of logged in user if not already and     add the logged In user id in the followers list of user id provided in the body of request if not already   
     * @summary 
     * @param {FollowProfileDto} followProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerAddFollower(followProfileDto: FollowProfileDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerAddFollower(followProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is for change password of login user
     * @summary 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerChangePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is for clear all recent search history of login user
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerClearAllRecentSearch(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerClearAllRecentSearch(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is for delete a recent search history data of login user
     * @summary 
     * @param {RecentSearchTextDto} recentSearchTextDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerClearRecentSearchText(recentSearchTextDto: RecentSearchTextDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerClearRecentSearchText(recentSearchTextDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for delete a user.
     * @summary 
     * @param {DeleteUserDTO} deleteUserDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerDeleteUser(deleteUserDTO: DeleteUserDTO, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerDeleteUser(deleteUserDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the user Details whose username is provided as the parameter.     
     * @summary 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the users profile.     It will return all the details of the user who is logged in.     It takes sub of logged in user from its token and then search with sub of user in the database. 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFindOne(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFindOne(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is for getting all the users who request for follow of login user
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerFollowRequests(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerFollowRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the users balances.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetBalances(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetBalances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for searching the users.Takes Optional Query parameters and returns array of objects of users whose name starts from the query search string.     Returns array of Documents of User if no error or exception Occurs.
     * @summary 
     * @param {string} search 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetCollaborators(search: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetCollaborators(search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for Getting all the followers of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of followers according to the request optional query parameter
     * @summary 
     * @param {string} userId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetFollowersSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetFollowers(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetFollowers(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for Getting all the following of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of following according to the request optional query parameter
     * @summary 
     * @param {string} userId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetFollowingSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetFollowing(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetFollowingSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetFollowing(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetMyFollowersSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetMyFollowers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMyFollowers(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the profile details of all the user who follow logged In User Profile and pass User id in param
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetMyFollowingSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetMyFollowing(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyFollowingSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMyFollowing(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for Getting all the posts of logged in User.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetMyPostsSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetMyPosts(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMyPosts(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for Getting all the posts of user id which is provides as request parameter.     If no error or exception occurs then return all or selected or limited number of posts according to the request optional query parameter
     * @summary 
     * @param {string} userId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetMyPostsByUserIdSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetMyPostsByUserId(userId: string, limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMyPostsByUserIdSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMyPostsByUserId(userId, limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetMySubscriptionsSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetMySubscriptions(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetMySubscriptionsSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMySubscriptions(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        This API is for getting my tiers list of logged in User.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetMyTiers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetMyTiers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the users settings for notifications.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetNotificationSettings(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetNotificationSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the users settings for privacy and security.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetPrivacySettings(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetPrivacySettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *         This API is for getting tiers list of user id which is provides as request parameter.
     * @summary 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetProfileTiers(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetProfileTiers(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to get the list of recommended user on base of several similarities.     
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetRecommendedProfiles(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetRecommendedProfiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetTrendingUsersSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetTrendingUsers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetTrendingUsersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetTrendingUsers(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for getting the user Details whose id is provided as the parameter.     
     * @summary 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetUser(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users with optionally paginations, sorting, and filtering.
     * @summary 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [sortCol] 
     * @param {UserControllerGetUsersSortDirEnum} [sortDir] 
     * @param {string} [filterCol] 
     * @param {string} [filterVal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetUsers(limit?: number, offset?: number, sortCol?: string, sortDir?: UserControllerGetUsersSortDirEnum, filterCol?: string, filterVal?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetUsers(limit, offset, sortCol, sortDir, filterCol, filterVal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *       This API is to update a user\'s lang settings.
     * @summary 
     * @param {string} userId 
     * @param {UserLangSettingDto} userLangSettingDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerLagSettings(userId: string, userLangSettingDto: UserLangSettingDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerLagSettings(userId, userLangSettingDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to update a user\'s profile setup step 1 details.     The name, username parameters are mandatory while description is optional.
     * @summary 
     * @param {ProfileSetupOneDto} profileSetupOneDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerProfileSetup(profileSetupOneDto: ProfileSetupOneDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerProfileSetup(profileSetupOneDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to update a user\'s profile step 3 details.
     * @summary 
     * @param {UserControllerProfileSetupAboutRequest} userControllerProfileSetupAboutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerProfileSetupAbout(userControllerProfileSetupAboutRequest: UserControllerProfileSetupAboutRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerProfileSetupAbout(userControllerProfileSetupAboutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to update a user\'s profile step 2 details.     It Takes multipart form data input and updates the existing logged in user avatar.     Returns the updated object after successful update.
     * @summary 
     * @param {boolean} [skip] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerProfileSetupAvatar(skip?: boolean, file?: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerProfileSetupAvatar(skip, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for remove a follower from login profile.   
     * @summary 
     * @param {UnFollowProfileDto} unFollowProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemoveFollower(unFollowProfileDto: UnFollowProfileDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemoveFollower(unFollowProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for unfollow a profile.   
     * @summary 
     * @param {UnFollowProfileDto} unFollowProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUnFollow(unFollowProfileDto: UnFollowProfileDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUnFollow(unFollowProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is for update status of follow request.   
     * @summary 
     * @param {UpdateFollowStatusDto} updateFollowStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUnFollower(updateFollowStatusDto: UpdateFollowStatusDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUnFollower(updateFollowStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to update a user\'s avatar.
     * @summary 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdateAvatar(file?: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateAvatar(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} search 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdateRecentHistory(search: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateRecentHistory(search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to update a user\'s settings.
     * @summary 
     * @param {string} userId 
     * @param {UserSettingDto} userSettingDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdateSettings(userId: string, userSettingDto: UserSettingDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateSettings(userId, userSettingDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to update a user\'s status.
     * @summary 
     * @param {UpdateStatusDto} updateStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdateStatus(updateStatusDto: UpdateStatusDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateStatus(updateStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to update a user details by userId param In user.     It Takes multipart form data input and updated the existing logged in user record.     returns the updated Object after successful update of records if no ERROR or EXCEPTION occurs.
     * @summary 
     * @param {string} userId 
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {string} [description] 
     * @param {Array<string>} [tags] 
     * @param {UserControllerUpdateUserByUserIdRequestSocials} [socials] 
     * @param {string} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdateUserByUserId(userId: string, name?: string, username?: string, description?: string, tags?: Array<string>, socials?: UserControllerUpdateUserByUserIdRequestSocials, category?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateUserByUserId(userId, name, username, description, tags, socials, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      This API is to check whether the username provided in the request parameters already exists or not.     If username already then return true otherwise return false
     * @summary 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUserNameExists(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUserNameExists(username, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserControllerGetFollowersSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetFollowersSortDirEnum = typeof UserControllerGetFollowersSortDirEnum[keyof typeof UserControllerGetFollowersSortDirEnum];
/**
 * @export
 */
export const UserControllerGetFollowingSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetFollowingSortDirEnum = typeof UserControllerGetFollowingSortDirEnum[keyof typeof UserControllerGetFollowingSortDirEnum];
/**
 * @export
 */
export const UserControllerGetMyFollowersSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetMyFollowersSortDirEnum = typeof UserControllerGetMyFollowersSortDirEnum[keyof typeof UserControllerGetMyFollowersSortDirEnum];
/**
 * @export
 */
export const UserControllerGetMyFollowingSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetMyFollowingSortDirEnum = typeof UserControllerGetMyFollowingSortDirEnum[keyof typeof UserControllerGetMyFollowingSortDirEnum];
/**
 * @export
 */
export const UserControllerGetMyPostsSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetMyPostsSortDirEnum = typeof UserControllerGetMyPostsSortDirEnum[keyof typeof UserControllerGetMyPostsSortDirEnum];
/**
 * @export
 */
export const UserControllerGetMyPostsByUserIdSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetMyPostsByUserIdSortDirEnum = typeof UserControllerGetMyPostsByUserIdSortDirEnum[keyof typeof UserControllerGetMyPostsByUserIdSortDirEnum];
/**
 * @export
 */
export const UserControllerGetMySubscriptionsSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetMySubscriptionsSortDirEnum = typeof UserControllerGetMySubscriptionsSortDirEnum[keyof typeof UserControllerGetMySubscriptionsSortDirEnum];
/**
 * @export
 */
export const UserControllerGetTrendingUsersSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetTrendingUsersSortDirEnum = typeof UserControllerGetTrendingUsersSortDirEnum[keyof typeof UserControllerGetTrendingUsersSortDirEnum];
/**
 * @export
 */
export const UserControllerGetUsersSortDirEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type UserControllerGetUsersSortDirEnum = typeof UserControllerGetUsersSortDirEnum[keyof typeof UserControllerGetUsersSortDirEnum];


/**
 * WithdrawalApi - axios parameter creator
 * @export
 */
export const WithdrawalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API is to confirm withdrawal using OTP send via email
         * @summary 
         * @param {WithdrawalConfirmDto} withdrawalConfirmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalControllerWithdrawalConfirm: async (withdrawalConfirmDto: WithdrawalConfirmDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalConfirmDto' is not null or undefined
            assertParamExists('withdrawalControllerWithdrawalConfirm', 'withdrawalConfirmDto', withdrawalConfirmDto)
            const localVarPath = `/v1/withdrawal/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawalConfirmDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API is for a withdrawal request
         * @summary 
         * @param {WithdrawalRequestDto} withdrawalRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalControllerWithdrawalRequest: async (withdrawalRequestDto: WithdrawalRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalRequestDto' is not null or undefined
            assertParamExists('withdrawalControllerWithdrawalRequest', 'withdrawalRequestDto', withdrawalRequestDto)
            const localVarPath = `/v1/withdrawal/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawalRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalApi - functional programming interface
 * @export
 */
export const WithdrawalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithdrawalApiAxiosParamCreator(configuration)
    return {
        /**
         * This API is to confirm withdrawal using OTP send via email
         * @summary 
         * @param {WithdrawalConfirmDto} withdrawalConfirmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawalControllerWithdrawalConfirm(withdrawalConfirmDto: WithdrawalConfirmDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawalControllerWithdrawalConfirm(withdrawalConfirmDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalApi.withdrawalControllerWithdrawalConfirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This API is for a withdrawal request
         * @summary 
         * @param {WithdrawalRequestDto} withdrawalRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawalControllerWithdrawalRequest(withdrawalRequestDto: WithdrawalRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerSignup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawalControllerWithdrawalRequest(withdrawalRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalApi.withdrawalControllerWithdrawalRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WithdrawalApi - factory interface
 * @export
 */
export const WithdrawalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithdrawalApiFp(configuration)
    return {
        /**
         * This API is to confirm withdrawal using OTP send via email
         * @summary 
         * @param {WithdrawalConfirmDto} withdrawalConfirmDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalControllerWithdrawalConfirm(withdrawalConfirmDto: WithdrawalConfirmDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.withdrawalControllerWithdrawalConfirm(withdrawalConfirmDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This API is for a withdrawal request
         * @summary 
         * @param {WithdrawalRequestDto} withdrawalRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalControllerWithdrawalRequest(withdrawalRequestDto: WithdrawalRequestDto, options?: any): AxiosPromise<AuthControllerSignup200Response> {
            return localVarFp.withdrawalControllerWithdrawalRequest(withdrawalRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalApi - object-oriented interface
 * @export
 * @class WithdrawalApi
 * @extends {BaseAPI}
 */
export class WithdrawalApi extends BaseAPI {
    /**
     * This API is to confirm withdrawal using OTP send via email
     * @summary 
     * @param {WithdrawalConfirmDto} withdrawalConfirmDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApi
     */
    public withdrawalControllerWithdrawalConfirm(withdrawalConfirmDto: WithdrawalConfirmDto, options?: RawAxiosRequestConfig) {
        return WithdrawalApiFp(this.configuration).withdrawalControllerWithdrawalConfirm(withdrawalConfirmDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is for a withdrawal request
     * @summary 
     * @param {WithdrawalRequestDto} withdrawalRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithdrawalApi
     */
    public withdrawalControllerWithdrawalRequest(withdrawalRequestDto: WithdrawalRequestDto, options?: RawAxiosRequestConfig) {
        return WithdrawalApiFp(this.configuration).withdrawalControllerWithdrawalRequest(withdrawalRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



